<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="from selenium import webdriver&#10;from selenium.webdriver.chrome.options import Options&#10;from selenium.webdriver.common.by import By&#10;from selenium.webdriver.support.ui import WebDriverWait&#10;from selenium.webdriver.support import expected_conditions as EC&#10;import logging&#10;from PIL import Image&#10;from io import BytesIO&#10;from concurrent.futures import ThreadPoolExecutor, as_completed&#10;import threading&#10;from datetime import datetime&#10;import json&#10;&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s - %(levelname)s - %(message)s',&#10;    datefmt='%Y-%m-%d %H:%M:%S'&#10;)&#10;logger = logging.getLogger(__name__)&#10;&#10;# Global lock to prevent concurrent driver initialization&#10;_driver_init_lock = threading.Lock()&#10;&#10;# Global bandwidth tracking&#10;_total_bandwidth_lock = threading.Lock()&#10;_global_bandwidth_stats = {&#10;    'total_sent': 0,&#10;    'total_received': 0,&#10;    'total_requests': 0&#10;}&#10;&#10;# ============================================&#10;# EXPIRATION CONFIGURATION&#10;# ============================================&#10;# Set the expiration date (YYYY, MM, DD, HH, MM, SS)&#10;# After this date, the software will stop working for all users&#10;# EXPIRATION_DATE = datetime(2025, 10, 17, 23, 59, 59)  # Expires on October 17, 2025 at 11:59:59 PM&#10;EXPIRATION_DATE = datetime(2025, 10, 19, 23, 59, 59)  # Expires on October 17, 2025 at 11:59:59 PM&#10;&#10;# Set to None to disable expiration&#10;# EXPIRATION_DATE = None&#10;# ============================================&#10;&#10;class ExpirationChecker:&#10;    &quot;&quot;&quot;Handles software expiration logic&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def check_expiration():&#10;        &quot;&quot;&quot;Check if software has expired. Returns (expired, message)&quot;&quot;&quot;&#10;&#10;        # If no expiration date is set, return not expired&#10;        if EXPIRATION_DATE is None:&#10;            return False, &quot;No expiration set&quot;&#10;&#10;        # Check if current date is past expiration date&#10;        now = datetime.now()&#10;        if now &gt; EXPIRATION_DATE:&#10;            days_expired = (now - EXPIRATION_DATE).days&#10;            return True, f&quot;This software expired on {EXPIRATION_DATE.strftime('%B %d, %Y')} ({days_expired} days ago)&quot;&#10;        else:&#10;            days_remaining = (EXPIRATION_DATE - now).days&#10;            hours_remaining = int((EXPIRATION_DATE - now).seconds / 3600)&#10;&#10;            # Warn if expiring soon&#10;            if days_remaining &lt;= 3:&#10;                logger.warning(f&quot;Software will expire in {days_remaining} days and {hours_remaining} hours!&quot;)&#10;&#10;            return False, f&quot;Software expires on {EXPIRATION_DATE.strftime('%B %d, %Y at %I:%M %p')}&quot;&#10;&#10;&#10;class FacebookNumberChecker:&#10;    def __init__(self, headless=False, wait_timeout=30):  # Reduced from 60 to 30 seconds&#10;        # Check expiration before initializing&#10;        expired, message = ExpirationChecker.check_expiration()&#10;        if expired:&#10;            raise Exception(f&quot;SOFTWARE EXPIRED: {message}&quot;)&#10;&#10;        logger.info(f&quot;Expiration status: {message}&quot;)&#10;&#10;        self.headless = headless&#10;        self.wait_timeout = wait_timeout&#10;        self.driver = None&#10;        self.wait = None&#10;        self.current_phone_number = None&#10;        self.continuation = True&#10;        self.reached_success = False  # Track if verification page was reached&#10;        self.error_message = None  # Track specific error message&#10;&#10;        # Bandwidth tracking for this instance&#10;        self.bandwidth_stats = {&#10;            'bytes_sent': 0,&#10;            'bytes_received': 0,&#10;            'requests_count': 0&#10;        }&#10;&#10;    def setup_driver(self):&#10;        # Double-check expiration before setup&#10;        expired, message = ExpirationChecker.check_expiration()&#10;        if expired:&#10;            raise Exception(f&quot;SOFTWARE EXPIRED: {message}&quot;)&#10;&#10;        options = Options()&#10;&#10;        # Set headless mode properly&#10;        if self.headless:&#10;            options.add_argument('--headless=new')  # Use new headless mode for better performance&#10;&#10;        # Performance optimizations&#10;        options.add_argument('--disable-blink-features=AutomationControlled')&#10;        options.add_argument('--disable-dev-shm-usage')&#10;        options.add_argument('--no-sandbox')&#10;        options.add_argument('--disable-gpu')&#10;        options.add_argument('--disable-extensions')&#10;        options.add_argument('--disable-plugins')&#10;        options.add_argument('--disable-popup-blocking')&#10;        options.add_argument('--disable-notifications')&#10;        options.add_argument('--disable-infobars')&#10;        options.add_argument('--disable-logging')&#10;        options.add_argument('--log-level=3')&#10;        options.add_argument('--silent')&#10;        options.add_experimental_option('excludeSwitches', ['enable-logging', 'enable-automation'])&#10;        options.add_experimental_option('useAutomationExtension', False)&#10;&#10;        # Set page load strategy to 'eager' - don't wait for all resources&#10;        options.page_load_strategy = 'eager'&#10;&#10;        # Disable images and other unnecessary resources via preferences&#10;        prefs = {&#10;            'profile.default_content_setting_values': {&#10;                'images': 2,  # Disable images - major speedup&#10;                'plugins': 2,&#10;                'popups': 2,&#10;                'geolocation': 2,&#10;                'notifications': 2,&#10;                'media_stream': 2,&#10;            },&#10;            'profile.managed_default_content_settings.images': 2&#10;        }&#10;        options.add_experimental_option('prefs', prefs)&#10;&#10;        # Use lock to prevent concurrent driver initialization&#10;        with _driver_init_lock:&#10;            self.driver = webdriver.Chrome(options=options)&#10;&#10;        # Enable Performance logging to track network activity&#10;        self.driver.execute_cdp_cmd('Network.enable', {})&#10;&#10;        # Reduced wait timeout and faster polling&#10;        self.wait = WebDriverWait(self.driver, self.wait_timeout, poll_frequency=0.3)  # Poll every 0.3s instead of default 0.5s&#10;&#10;        width = 1200&#10;        height = int(width * 9 / 16)&#10;        self.driver.set_window_size(width, height)&#10;&#10;        logger.info(f&quot;Browser initialized (headless={self.headless}) with size: {width}x{height}&quot;)&#10;&#10;    def get_network_stats(self):&#10;        &quot;&quot;&quot;Retrieve network statistics from Chrome DevTools Protocol&quot;&quot;&quot;&#10;        try:&#10;            # Get performance metrics&#10;            metrics = self.driver.execute_cdp_cmd('Performance.getMetrics', {})&#10;&#10;            # Get network data from performance logs&#10;            logs = self.driver.get_log('performance')&#10;&#10;            bytes_sent = 0&#10;            bytes_received = 0&#10;            request_count = 0&#10;&#10;            for entry in logs:&#10;                try:&#10;                    log_message = json.loads(entry['message'])&#10;                    message = log_message.get('message', {})&#10;                    method = message.get('method', '')&#10;&#10;                    # Track response received events&#10;                    if method == 'Network.responseReceived':&#10;                        params = message.get('params', {})&#10;                        response = params.get('response', {})&#10;&#10;                        # Get encoded data length (compressed size) or use content length&#10;                        encoded_length = response.get('encodedDataLength', 0)&#10;&#10;                        if encoded_length &gt; 0:&#10;                            bytes_received += encoded_length&#10;                            request_count += 1&#10;&#10;                    # Track request will be sent events (for upload size)&#10;                    elif method == 'Network.requestWillBeSent':&#10;                        params = message.get('params', {})&#10;                        request = params.get('request', {})&#10;&#10;                        # Estimate request size from headers and post data&#10;                        headers = request.get('headers', {})&#10;                        post_data = request.get('postData', '')&#10;&#10;                        # Rough estimate of request size&#10;                        header_size = sum(len(str(k)) + len(str(v)) for k, v in headers.items())&#10;                        post_data_size = len(post_data) if post_data else 0&#10;&#10;                        bytes_sent += header_size + post_data_size&#10;&#10;                except Exception as e:&#10;                    # Skip problematic log entries&#10;                    continue&#10;&#10;            return {&#10;                'bytes_sent': bytes_sent,&#10;                'bytes_received': bytes_received,&#10;                'requests_count': request_count&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.debug(f&quot;Could not retrieve network stats: {e}&quot;)&#10;            return {&#10;                'bytes_sent': 0,&#10;                'bytes_received': 0,&#10;                'requests_count': 0&#10;            }&#10;&#10;    def update_bandwidth_stats(self):&#10;        &quot;&quot;&quot;Update bandwidth statistics for this checker instance&quot;&quot;&quot;&#10;        stats = self.get_network_stats()&#10;        self.bandwidth_stats['bytes_sent'] += stats['bytes_sent']&#10;        self.bandwidth_stats['bytes_received'] += stats['bytes_received']&#10;        self.bandwidth_stats['requests_count'] += stats['requests_count']&#10;&#10;    @staticmethod&#10;    def format_bytes(bytes_value):&#10;        &quot;&quot;&quot;Convert bytes to human-readable format&quot;&quot;&quot;&#10;        for unit in ['B', 'KB', 'MB', 'GB']:&#10;            if bytes_value &lt; 1024.0:&#10;                return f&quot;{bytes_value:.2f} {unit}&quot;&#10;            bytes_value /= 1024.0&#10;        return f&quot;{bytes_value:.2f} TB&quot;&#10;&#10;    def wait_for_text_and_execute(self, text_actions_map):&#10;        &quot;&quot;&quot;&#10;        Wait for one of multiple texts to appear and execute corresponding action.&#10;        Checks all texts simultaneously by getting page source once per poll.&#10;        text_actions_map: dict with text as key and action function as value&#10;        &quot;&quot;&quot;&#10;        def check_all_texts(driver):&#10;            # Get page source once per poll for efficiency&#10;            try:&#10;                page_source = driver.page_source&#10;            except:&#10;                return False&#10;&#10;            # Check all texts against the same page source&#10;            for text, action in text_actions_map.items():&#10;                if text in page_source:&#10;                    # Verify with actual element find to ensure it's visible/present&#10;                    try:&#10;                        element = driver.find_element(By.XPATH, f&quot;//*[contains(text(), '{text}')]&quot;)&#10;                        if element:&#10;                            return (text, action)&#10;                    except:&#10;                        continue&#10;            return False&#10;&#10;        try:&#10;            result = self.wait.until(check_all_texts)&#10;            if result:&#10;                text, action = result&#10;                logger.info(f&quot;Found text: '{text}'&quot;)&#10;                action()&#10;                return text&#10;        except:&#10;            pass&#10;&#10;        return None&#10;&#10;    def search_phone_number(self, phone_number):&#10;        self.current_phone_number = phone_number&#10;        self.driver.get(&quot;https://www.facebook.com/login/identify/&quot;)&#10;&#10;        email_input = self.wait.until(&#10;            EC.presence_of_element_located((By.ID, &quot;identify_email&quot;))&#10;        )&#10;&#10;        email_input.clear()&#10;        email_input.send_keys(phone_number)&#10;&#10;        search_button = self.wait.until(&#10;            EC.element_to_be_clickable((By.ID, &quot;did_submit&quot;))&#10;        )&#10;        search_button.click()&#10;        logger.info(f&quot;Searched for phone number: {phone_number}&quot;)&#10;&#10;    def select_account(self):&#10;        first_account_link = self.wait.until(&#10;            EC.element_to_be_clickable((By.XPATH, &quot;//a[contains(text(), 'This is my account')]&quot;))&#10;        )&#10;        first_account_link.click()&#10;        logger.info(&quot;First account selected&quot;)&#10;&#10;    def continue_send_code(self):&#10;        phone_to_match = ''.join(filter(str.isdigit, self.current_phone_number))&#10;&#10;        all_radios = self.wait.until(&#10;            EC.presence_of_all_elements_located((By.XPATH, &quot;//input[@type='radio' and @name='recover_method']&quot;))&#10;        )&#10;&#10;        sms_radio_to_click = None&#10;        for radio in all_radios:&#10;            try:&#10;                radio_id = radio.get_attribute('id')&#10;&#10;                # Only process SMS options&#10;                if not radio_id or not radio_id.startswith('send_sms:'):&#10;                    continue&#10;&#10;                # Find the label associated with this radio button&#10;                label = self.driver.find_element(By.XPATH, f&quot;//label[@for='{radio_id}']&quot;)&#10;                label_text = label.text&#10;&#10;                # Check if it contains &quot;Send code via SMS&quot;&#10;                if &quot;Send code via SMS&quot; not in label_text:&#10;                    continue&#10;&#10;                # Extract phone number from the label (it's in the second div)&#10;                phone_in_label = ''.join(filter(str.isdigit, label_text))&#10;&#10;                # Match the phone number - look for full match or partial match&#10;                # The phone number appears after &quot;Send code via SMS&quot; text&#10;                if phone_to_match == phone_in_label or phone_to_match in phone_in_label or phone_in_label in phone_to_match:&#10;                    # Check if this is NOT a masked number (masked numbers have asterisks)&#10;                    if '*' not in label_text or phone_to_match in label_text.replace('+', ''):&#10;                        sms_radio_to_click = radio&#10;                        break&#10;            except Exception as e:&#10;                logger.debug(f&quot;Error processing radio button: {e}&quot;)&#10;                continue&#10;&#10;        if not sms_radio_to_click:&#10;            # No SMS option found - set error and stop&#10;            self.continuation = False&#10;            self.error_message = &quot;Can't find the 'Send code via SMS' option.&quot;&#10;            logger.info(&quot;SMS verification option not available for this account&quot;)&#10;            return&#10;&#10;        if not sms_radio_to_click.is_selected():&#10;            sms_radio_to_click.click()&#10;            logger.info(&quot;SMS radio button clicked&quot;)&#10;&#10;        continue_button = self.wait.until(&#10;            EC.element_to_be_clickable((By.XPATH, &quot;//button[@name='reset_action' and @type='submit' and contains(text(), 'Continue')]&quot;))&#10;        )&#10;        continue_button.click()&#10;        logger.info(&quot;SMS code option selected and Continue clicked&quot;)&#10;&#10;    def continue_phone_number(self):&#10;        pass&#10;&#10;    def on_disabled(self):&#10;        self.continuation = False&#10;        self.error_message = &quot;Account is disabled&quot;&#10;        logger.info(&quot;Account is disabled&quot;)&#10;&#10;    def on_verification_send(self):&#10;        self.continuation = False&#10;        self.reached_success = True  # Set flag when verification code page is reached&#10;        logger.info(&quot;Verification code input page reached&quot;)&#10;&#10;    def no_search_results(self):&#10;        self.continuation = False&#10;        self.error_message = &quot;Facebook account isn't found&quot;&#10;        logger.info(&quot;Facebook account isn't found&quot;)&#10;&#10;    def on_robot_detected(self):&#10;        self.continuation = False&#10;        self.error_message = &quot;Robot detected - CAPTCHA required&quot;&#10;        logger.info(&quot;Robot detected&quot;)&#10;&#10;    def try_another_way(self):&#10;        try:&#10;            try_another_way_button = self.wait.until(&#10;                EC.element_to_be_clickable((By.XPATH, &quot;//a[@name='tryanotherway' and contains(text(), 'Try another way')]&quot;))&#10;            )&#10;            try_another_way_button.click()&#10;            logger.info(&quot;Clicked 'Try another way' button&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error clicking 'Try another way' button: {e}&quot;)&#10;            # Try alternative selector&#10;            try:&#10;                try_another_way_button = self.wait.until(&#10;                    EC.element_to_be_clickable((By.NAME, &quot;tryanotherway&quot;))&#10;                )&#10;                try_another_way_button.click()&#10;                logger.info(&quot;Clicked 'Try another way' button using alternative selector&quot;)&#10;            except Exception as e2:&#10;                logger.error(f&quot;Failed with alternative selector too: {e2}&quot;)&#10;                raise&#10;&#10;    def reload_page(self):&#10;        self.driver.refresh()&#10;&#10;    def direct_code_send(self):&#10;        &quot;&quot;&quot;Handle the case where Facebook directly offers to send a code to the phone number&quot;&quot;&quot;&#10;        try:&#10;            # Click the Continue button to send the verification code&#10;            continue_button = self.wait.until(&#10;                EC.element_to_be_clickable((By.XPATH, &quot;//button[@type='submit' and contains(text(), 'Continue')]&quot;))&#10;            )&#10;            continue_button.click()&#10;            logger.info(&quot;Clicked Continue button to send verification code directly&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error clicking Continue button: {e}&quot;)&#10;            # Try alternative selector&#10;            try:&#10;                continue_button = self.wait.until(&#10;                    EC.element_to_be_clickable((By.XPATH, &quot;//button[@type='submit']&quot;))&#10;                )&#10;                continue_button.click()&#10;                logger.info(&quot;Clicked Continue button using alternative selector&quot;)&#10;            except Exception as e2:&#10;                logger.error(f&quot;Failed with alternative selector too: {e2}&quot;)&#10;                raise&#10;&#10;    def handle_continuation(self):&#10;        try:&#10;            text_actions = {&#10;                &quot;These accounts matched your search&quot;: self.select_account,&#10;                &quot;How do you want to receive the code to reset your password?&quot;: self.continue_send_code,&#10;                &quot;How do you want to get the code to reset your password?&quot;: self.continue_send_code,&#10;                &quot;Before we send the code, enter these letters and numbers&quot;: self.on_robot_detected,&#10;                &quot;Enter security code&quot;: self.on_verification_send,&#10;                &quot;Account disabled&quot;: self.on_disabled,&#10;                &quot;No search results&quot;: self.no_search_results,&#10;                &quot;Log in as&quot;: self.try_another_way,&#10;                &quot;Log in to&quot;: self.try_another_way,&#10;                &quot;Reload page&quot;: self.reload_page,&#10;                &quot;We can send a login code to:&quot;: self.direct_code_send,&#10;            }&#10;&#10;            while self.continuation:&#10;                found_text = self.wait_for_text_and_execute(text_actions)&#10;&#10;                if not found_text:&#10;                    logger.warning(&quot;No expected text found&quot;)&#10;                    break&#10;&#10;                # Strict mode: remove the executed text action from the map&#10;                if found_text in text_actions:&#10;                    del text_actions[found_text]&#10;&#10;                # If all actions are exhausted, break&#10;                if not text_actions:&#10;                    break&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;An error occurred: {e}&quot;)&#10;            raise&#10;&#10;&#10;    def page_preview(self):&#10;        screenshot_bytes = self.driver.get_screenshot_as_png()&#10;        image = Image.open(BytesIO(screenshot_bytes))&#10;        image.show()&#10;        logger.info(&quot;Screenshot preview opened&quot;)&#10;&#10;    def close(self):&#10;        if self.driver:&#10;            # Get final bandwidth statistics before closing&#10;            self.update_bandwidth_stats()&#10;&#10;            # Log per-session bandwidth usage&#10;            total_bandwidth = self.bandwidth_stats['bytes_sent'] + self.bandwidth_stats['bytes_received']&#10;            logger.info(f&quot;Bandwidth for this check: Sent={self.format_bytes(self.bandwidth_stats['bytes_sent'])}, &quot;&#10;                       f&quot;Received={self.format_bytes(self.bandwidth_stats['bytes_received'])}, &quot;&#10;                       f&quot;Total={self.format_bytes(total_bandwidth)}, &quot;&#10;                       f&quot;Requests={self.bandwidth_stats['requests_count']}&quot;)&#10;&#10;            # Update global bandwidth statistics&#10;            with _total_bandwidth_lock:&#10;                _global_bandwidth_stats['total_sent'] += self.bandwidth_stats['bytes_sent']&#10;                _global_bandwidth_stats['total_received'] += self.bandwidth_stats['bytes_received']&#10;                _global_bandwidth_stats['total_requests'] += self.bandwidth_stats['requests_count']&#10;&#10;            self.driver.quit()&#10;            logger.info(&quot;Browser closed&quot;)&#10;&#10;    def check_number(self, phone_number):&#10;        &quot;&quot;&quot;&#10;        Check a single phone number and return the result&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.search_phone_number(phone_number)&#10;            self.handle_continuation()&#10;&#10;            # Check if verification page was reached successfully&#10;            if self.reached_success:&#10;                return {&#10;                    'phone': phone_number,&#10;                    'status': 'success',&#10;                    'message': 'Verification code page reached'&#10;                }&#10;            # If we have a specific error message, return it&#10;            elif self.error_message:&#10;                return {&#10;                    'phone': phone_number,&#10;                    'status': 'failed',&#10;                    'message': self.error_message&#10;                }&#10;            # Otherwise, return unknown error&#10;            else:&#10;                return {&#10;                    'phone': phone_number,&#10;                    'status': 'failed',&#10;                    'message': 'Unknown error - didn\'t reach verification page'&#10;                }&#10;        except Exception as e:&#10;            logger.error(f&quot;Error checking {phone_number}: {e}&quot;)&#10;            return {&#10;                'phone': phone_number,&#10;                'status': 'error',&#10;                'message': str(e)&#10;            }&#10;&#10;&#10;def check_single_number(phone_number):&#10;    &quot;&quot;&quot;&#10;    Worker function to check a single phone number&#10;    &quot;&quot;&quot;&#10;    checker = FacebookNumberChecker(headless=False)&#10;    try:&#10;        checker.setup_driver()&#10;        result = checker.check_number(phone_number)&#10;        logger.info(f&quot;Completed check for {phone_number}: {result['status']}&quot;)&#10;        return result&#10;    except Exception as e:&#10;        logger.error(f&quot;Worker error for {phone_number}: {e}&quot;)&#10;        return {&#10;            'phone': phone_number,&#10;            'status': 'error',&#10;            'message': str(e)&#10;        }&#10;    finally:&#10;        checker.close()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    #&#10;    # nums = [&#10;    #     &quot;2250708139166&quot;, &quot;2250708135432&quot;, &quot;2250708136329&quot;, &quot;2250708137946&quot;, &quot;2250708130149&quot;, &quot;2250708132325&quot;,&#10;    #     &quot;2250708134921&quot;, &quot;2250708131254&quot;, &quot;2250708135326&quot;, &quot;2250708136921&quot;, &quot;2250708138627&quot;, &quot;2250708136804&quot;,&#10;    #     &quot;2250708133468&quot;, &quot;2250708130814&quot;, &quot;2250708132680&quot;, &quot;2250708131009&quot;, &quot;2250708136508&quot;, &quot;2250708135640&quot;,&#10;    #     &quot;2250708136254&quot;, &quot;2250708137888&quot;, &quot;2250708130404&quot;, &quot;2250708132032&quot;, &quot;2250708135700&quot;, &quot;2250708136514&quot;,&#10;    #     &quot;2250708133330&quot;, &quot;2250708137507&quot;, &quot;2250708131688&quot;, &quot;2250708132191&quot;, &quot;2250708134184&quot;, &quot;2250708135392&quot;,&#10;    #     &quot;2250708135811&quot;, &quot;2250708131936&quot;, &quot;2250708138942&quot;, &quot;2250708130543&quot;, &quot;2250708134441&quot;, &quot;2250708139822&quot;,&#10;    #     &quot;2250708133494&quot;, &quot;2250708131958&quot;, &quot;2250708130684&quot;, &quot;2250708136616&quot;, &quot;2250708130337&quot;, &quot;2250708131019&quot;,&#10;    #     &quot;2250708130369&quot;, &quot;2250708137183&quot;, &quot;2250708130469&quot;, &quot;2250708134024&quot;, &quot;2250708133098&quot;, &quot;2250708135786&quot;,&#10;    #     &quot;2250708131322&quot;, &quot;2250708138204&quot;, &quot;2250708139499&quot;, &quot;2250708138352&quot;, &quot;2250708134979&quot;, &quot;2250708139512&quot;,&#10;    #     &quot;2250708132538&quot;, &quot;2250708136979&quot;, &quot;2250708136863&quot;, &quot;2250708136665&quot;, &quot;2250708131689&quot;, &quot;2250708138575&quot;,&#10;    #     &quot;2250708134924&quot;, &quot;2250708130984&quot;, &quot;2250708138875&quot;, &quot;2250708131727&quot;, &quot;2250708136283&quot;, &quot;2250708132332&quot;,&#10;    #     &quot;2250708132646&quot;, &quot;2250708135113&quot;, &quot;2250708139954&quot;, &quot;2250708132201&quot;, &quot;2250708136558&quot;, &quot;2250708134414&quot;,&#10;    #     &quot;2250708131519&quot;, &quot;2250708135538&quot;, &quot;2250708130197&quot;, &quot;2250708131851&quot;, &quot;2250708133530&quot;, &quot;2250708130279&quot;,&#10;    #     &quot;2250708132252&quot;, &quot;2250708135809&quot;, &quot;2250708138185&quot;, &quot;2250708138513&quot;, &quot;2250708139799&quot;, &quot;2250708130520&quot;,&#10;    #     &quot;2250708138986&quot;, &quot;2250708133287&quot;, &quot;2250708134147&quot;, &quot;2250708131345&quot;, &quot;2250708131565&quot;, &quot;2250708132120&quot;,&#10;    #     &quot;2250708131610&quot;, &quot;2250708132501&quot;, &quot;2250708139948&quot;, &quot;2250708138734&quot;, &quot;2250708136500&quot;, &quot;2250708130826&quot;,&#10;    #     &quot;2250708138855&quot;, &quot;2250708139632&quot;, &quot;2250708136711&quot;, &quot;2250708136905&quot;&#10;    # ]&#10;&#10;    nums = [&#10;        &quot;2250708139166&quot;&#10;    ]&#10;&#10;    results = []&#10;&#10;    logger.info(f&quot;Starting to check {len(nums)} phone numbers with 5 concurrent workers&quot;)&#10;&#10;    with ThreadPoolExecutor(max_workers=1) as executor:&#10;        # Submit all tasks&#10;        future_to_phone = {executor.submit(check_single_number, phone): phone for phone in nums}&#10;&#10;        # Process completed tasks as they finish&#10;        for future in as_completed(future_to_phone):&#10;            phone = future_to_phone[future]&#10;            try:&#10;                result = future.result()&#10;                results.append(result)&#10;                logger.info(f&quot;Progress: {len(results)}/{len(nums)} completed&quot;)&#10;            except Exception as e:&#10;                logger.error(f&quot;Exception for {phone}: {e}&quot;)&#10;                results.append({&#10;                    'phone': phone,&#10;                    'status': 'error',&#10;                    'message': str(e)&#10;                })&#10;&#10;    # Print summary&#10;    logger.info(&quot;=&quot; * 50)&#10;    logger.info(&quot;FINAL RESULTS:&quot;)&#10;    logger.info(&quot;=&quot; * 50)&#10;&#10;    success_count = sum(1 for r in results if r['status'] == 'success')&#10;    error_count = sum(1 for r in results if r['status'] == 'error')&#10;&#10;    logger.info(f&quot;Total checked: {len(results)}&quot;)&#10;    logger.info(f&quot;Successful: {success_count}&quot;)&#10;    logger.info(f&quot;Errors: {error_count}&quot;)&#10;&#10;    logger.info(&quot;\nDetailed results:&quot;)&#10;    for result in results:&#10;        logger.info(f&quot;{result['phone']}: {result['status']} - {result['message']}&quot;)&#10;&#10;    # Print total bandwidth usage&#10;    logger.info(&quot;=&quot; * 50)&#10;    logger.info(&quot;TOTAL BANDWIDTH USAGE:&quot;)&#10;    logger.info(&quot;=&quot; * 50)&#10;    total_sent = _global_bandwidth_stats['total_sent']&#10;    total_received = _global_bandwidth_stats['total_received']&#10;    total_bandwidth = total_sent + total_received&#10;    total_requests = _global_bandwidth_stats['total_requests']&#10;&#10;    logger.info(f&quot;Total Sent: {FacebookNumberChecker.format_bytes(total_sent)}&quot;)&#10;    logger.info(f&quot;Total Received: {FacebookNumberChecker.format_bytes(total_received)}&quot;)&#10;    logger.info(f&quot;Total Bandwidth: {FacebookNumberChecker.format_bytes(total_bandwidth)}&quot;)&#10;    logger.info(f&quot;Total Requests: {total_requests}&quot;)&#10;&#10;    if len(results) &gt; 0:&#10;        avg_bandwidth_per_check = total_bandwidth / len(results)&#10;        logger.info(f&quot;Average Bandwidth per Check: {FacebookNumberChecker.format_bytes(avg_bandwidth_per_check)}&quot;)&#10;&#10;    logger.info(&quot;=&quot; * 50)&#10;" />
              <option name="updatedContent" value="from selenium import webdriver&#10;from selenium.webdriver.chrome.options import Options&#10;from selenium.webdriver.common.by import By&#10;from selenium.webdriver.support.ui import WebDriverWait&#10;from selenium.webdriver.support import expected_conditions as EC&#10;import logging&#10;from PIL import Image&#10;from io import BytesIO&#10;from concurrent.futures import ThreadPoolExecutor, as_completed&#10;import threading&#10;from datetime import datetime&#10;import json&#10;&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s - %(levelname)s - %(message)s',&#10;    datefmt='%Y-%m-%d %H:%M:%S'&#10;)&#10;logger = logging.getLogger(__name__)&#10;&#10;# Global lock to prevent concurrent driver initialization&#10;_driver_init_lock = threading.Lock()&#10;&#10;# Global bandwidth tracking&#10;_total_bandwidth_lock = threading.Lock()&#10;_global_bandwidth_stats = {&#10;    'total_sent': 0,&#10;    'total_received': 0,&#10;    'total_requests': 0&#10;}&#10;&#10;# ============================================&#10;# EXPIRATION CONFIGURATION&#10;# ============================================&#10;# Set the expiration date (YYYY, MM, DD, HH, MM, SS)&#10;# After this date, the software will stop working for all users&#10;# EXPIRATION_DATE = datetime(2025, 10, 17, 23, 59, 59)  # Expires on October 17, 2025 at 11:59:59 PM&#10;EXPIRATION_DATE = datetime(2025, 10, 19, 23, 59, 59)  # Expires on October 17, 2025 at 11:59:59 PM&#10;&#10;# Set to None to disable expiration&#10;# EXPIRATION_DATE = None&#10;# ============================================&#10;&#10;class ExpirationChecker:&#10;    &quot;&quot;&quot;Handles software expiration logic&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def check_expiration():&#10;        &quot;&quot;&quot;Check if software has expired. Returns (expired, message)&quot;&quot;&quot;&#10;&#10;        # If no expiration date is set, return not expired&#10;        if EXPIRATION_DATE is None:&#10;            return False, &quot;No expiration set&quot;&#10;&#10;        # Check if current date is past expiration date&#10;        now = datetime.now()&#10;        if now &gt; EXPIRATION_DATE:&#10;            days_expired = (now - EXPIRATION_DATE).days&#10;            return True, f&quot;This software expired on {EXPIRATION_DATE.strftime('%B %d, %Y')} ({days_expired} days ago)&quot;&#10;        else:&#10;            days_remaining = (EXPIRATION_DATE - now).days&#10;            hours_remaining = int((EXPIRATION_DATE - now).seconds / 3600)&#10;&#10;            # Warn if expiring soon&#10;            if days_remaining &lt;= 3:&#10;                logger.warning(f&quot;Software will expire in {days_remaining} days and {hours_remaining} hours!&quot;)&#10;&#10;            return False, f&quot;Software expires on {EXPIRATION_DATE.strftime('%B %d, %Y at %I:%M %p')}&quot;&#10;&#10;&#10;class FacebookNumberChecker:&#10;    def __init__(self, headless=False, wait_timeout=30):  # Reduced from 60 to 30 seconds&#10;        # Check expiration before initializing&#10;        expired, message = ExpirationChecker.check_expiration()&#10;        if expired:&#10;            raise Exception(f&quot;SOFTWARE EXPIRED: {message}&quot;)&#10;&#10;        logger.info(f&quot;Expiration status: {message}&quot;)&#10;&#10;        self.headless = headless&#10;        self.wait_timeout = wait_timeout&#10;        self.driver = None&#10;        self.wait = None&#10;        self.current_phone_number = None&#10;        self.continuation = True&#10;        self.reached_success = False  # Track if verification page was reached&#10;        self.error_message = None  # Track specific error message&#10;&#10;        # Bandwidth tracking for this instance&#10;        self.bandwidth_stats = {&#10;            'bytes_sent': 0,&#10;            'bytes_received': 0,&#10;            'requests_count': 0&#10;        }&#10;&#10;    def setup_driver(self):&#10;        # Double-check expiration before setup&#10;        expired, message = ExpirationChecker.check_expiration()&#10;        if expired:&#10;            raise Exception(f&quot;SOFTWARE EXPIRED: {message}&quot;)&#10;&#10;        options = Options()&#10;&#10;        # Set headless mode properly&#10;        if self.headless:&#10;            options.add_argument('--headless=new')  # Use new headless mode for better performance&#10;&#10;        # Performance optimizations&#10;        options.add_argument('--disable-blink-features=AutomationControlled')&#10;        options.add_argument('--disable-dev-shm-usage')&#10;        options.add_argument('--no-sandbox')&#10;        options.add_argument('--disable-gpu')&#10;        options.add_argument('--disable-extensions')&#10;        options.add_argument('--disable-plugins')&#10;        options.add_argument('--disable-popup-blocking')&#10;        options.add_argument('--disable-notifications')&#10;        options.add_argument('--disable-infobars')&#10;        # Don't disable logging completely - we need performance logs&#10;        # options.add_argument('--disable-logging')&#10;        options.add_argument('--log-level=3')&#10;        options.add_argument('--silent')&#10;        options.add_experimental_option('excludeSwitches', ['enable-logging', 'enable-automation'])&#10;        options.add_experimental_option('useAutomationExtension', False)&#10;&#10;        # Set page load strategy to 'eager' - don't wait for all resources&#10;        options.page_load_strategy = 'eager'&#10;&#10;        # Disable images and other unnecessary resources via preferences&#10;        prefs = {&#10;            'profile.default_content_setting_values': {&#10;                'images': 2,  # Disable images - major speedup&#10;                'plugins': 2,&#10;                'popups': 2,&#10;                'geolocation': 2,&#10;                'notifications': 2,&#10;                'media_stream': 2,&#10;            },&#10;            'profile.managed_default_content_settings.images': 2&#10;        }&#10;        options.add_experimental_option('prefs', prefs)&#10;        &#10;        # Enable performance logging to capture network data&#10;        options.set_capability('goog:loggingPrefs', {'performance': 'ALL'})&#10;&#10;        # Use lock to prevent concurrent driver initialization&#10;        with _driver_init_lock:&#10;            self.driver = webdriver.Chrome(options=options)&#10;&#10;        # Enable Performance logging to track network activity&#10;        self.driver.execute_cdp_cmd('Network.enable', {})&#10;&#10;        # Reduced wait timeout and faster polling&#10;        self.wait = WebDriverWait(self.driver, self.wait_timeout, poll_frequency=0.3)  # Poll every 0.3s instead of default 0.5s&#10;&#10;        width = 1200&#10;        height = int(width * 9 / 16)&#10;        self.driver.set_window_size(width, height)&#10;&#10;        logger.info(f&quot;Browser initialized (headless={self.headless}) with size: {width}x{height}&quot;)&#10;&#10;    def get_network_stats(self):&#10;        &quot;&quot;&quot;Retrieve network statistics from Chrome DevTools Protocol&quot;&quot;&quot;&#10;        try:&#10;            # Get performance metrics&#10;            metrics = self.driver.execute_cdp_cmd('Performance.getMetrics', {})&#10;&#10;            # Get network data from performance logs&#10;            logs = self.driver.get_log('performance')&#10;&#10;            bytes_sent = 0&#10;            bytes_received = 0&#10;            request_count = 0&#10;&#10;            for entry in logs:&#10;                try:&#10;                    log_message = json.loads(entry['message'])&#10;                    message = log_message.get('message', {})&#10;                    method = message.get('method', '')&#10;&#10;                    # Track response received events&#10;                    if method == 'Network.responseReceived':&#10;                        params = message.get('params', {})&#10;                        response = params.get('response', {})&#10;&#10;                        # Get encoded data length (compressed size) or use content length&#10;                        encoded_length = response.get('encodedDataLength', 0)&#10;&#10;                        if encoded_length &gt; 0:&#10;                            bytes_received += encoded_length&#10;                            request_count += 1&#10;&#10;                    # Track request will be sent events (for upload size)&#10;                    elif method == 'Network.requestWillBeSent':&#10;                        params = message.get('params', {})&#10;                        request = params.get('request', {})&#10;&#10;                        # Estimate request size from headers and post data&#10;                        headers = request.get('headers', {})&#10;                        post_data = request.get('postData', '')&#10;&#10;                        # Rough estimate of request size&#10;                        header_size = sum(len(str(k)) + len(str(v)) for k, v in headers.items())&#10;                        post_data_size = len(post_data) if post_data else 0&#10;&#10;                        bytes_sent += header_size + post_data_size&#10;&#10;                except Exception as e:&#10;                    # Skip problematic log entries&#10;                    continue&#10;&#10;            return {&#10;                'bytes_sent': bytes_sent,&#10;                'bytes_received': bytes_received,&#10;                'requests_count': request_count&#10;            }&#10;&#10;        except Exception as e:&#10;            logger.debug(f&quot;Could not retrieve network stats: {e}&quot;)&#10;            return {&#10;                'bytes_sent': 0,&#10;                'bytes_received': 0,&#10;                'requests_count': 0&#10;            }&#10;&#10;    def update_bandwidth_stats(self):&#10;        &quot;&quot;&quot;Update bandwidth statistics for this checker instance&quot;&quot;&quot;&#10;        stats = self.get_network_stats()&#10;        self.bandwidth_stats['bytes_sent'] += stats['bytes_sent']&#10;        self.bandwidth_stats['bytes_received'] += stats['bytes_received']&#10;        self.bandwidth_stats['requests_count'] += stats['requests_count']&#10;&#10;    @staticmethod&#10;    def format_bytes(bytes_value):&#10;        &quot;&quot;&quot;Convert bytes to human-readable format&quot;&quot;&quot;&#10;        for unit in ['B', 'KB', 'MB', 'GB']:&#10;            if bytes_value &lt; 1024.0:&#10;                return f&quot;{bytes_value:.2f} {unit}&quot;&#10;            bytes_value /= 1024.0&#10;        return f&quot;{bytes_value:.2f} TB&quot;&#10;&#10;    def wait_for_text_and_execute(self, text_actions_map):&#10;        &quot;&quot;&quot;&#10;        Wait for one of multiple texts to appear and execute corresponding action.&#10;        Checks all texts simultaneously by getting page source once per poll.&#10;        text_actions_map: dict with text as key and action function as value&#10;        &quot;&quot;&quot;&#10;        def check_all_texts(driver):&#10;            # Get page source once per poll for efficiency&#10;            try:&#10;                page_source = driver.page_source&#10;            except:&#10;                return False&#10;&#10;            # Check all texts against the same page source&#10;            for text, action in text_actions_map.items():&#10;                if text in page_source:&#10;                    # Verify with actual element find to ensure it's visible/present&#10;                    try:&#10;                        element = driver.find_element(By.XPATH, f&quot;//*[contains(text(), '{text}')]&quot;)&#10;                        if element:&#10;                            return (text, action)&#10;                    except:&#10;                        continue&#10;            return False&#10;&#10;        try:&#10;            result = self.wait.until(check_all_texts)&#10;            if result:&#10;                text, action = result&#10;                logger.info(f&quot;Found text: '{text}'&quot;)&#10;                action()&#10;                return text&#10;        except:&#10;            pass&#10;&#10;        return None&#10;&#10;    def search_phone_number(self, phone_number):&#10;        self.current_phone_number = phone_number&#10;        self.driver.get(&quot;https://www.facebook.com/login/identify/&quot;)&#10;&#10;        email_input = self.wait.until(&#10;            EC.presence_of_element_located((By.ID, &quot;identify_email&quot;))&#10;        )&#10;&#10;        email_input.clear()&#10;        email_input.send_keys(phone_number)&#10;&#10;        search_button = self.wait.until(&#10;            EC.element_to_be_clickable((By.ID, &quot;did_submit&quot;))&#10;        )&#10;        search_button.click()&#10;        logger.info(f&quot;Searched for phone number: {phone_number}&quot;)&#10;&#10;    def select_account(self):&#10;        first_account_link = self.wait.until(&#10;            EC.element_to_be_clickable((By.XPATH, &quot;//a[contains(text(), 'This is my account')]&quot;))&#10;        )&#10;        first_account_link.click()&#10;        logger.info(&quot;First account selected&quot;)&#10;&#10;    def continue_send_code(self):&#10;        phone_to_match = ''.join(filter(str.isdigit, self.current_phone_number))&#10;&#10;        all_radios = self.wait.until(&#10;            EC.presence_of_all_elements_located((By.XPATH, &quot;//input[@type='radio' and @name='recover_method']&quot;))&#10;        )&#10;&#10;        sms_radio_to_click = None&#10;        for radio in all_radios:&#10;            try:&#10;                radio_id = radio.get_attribute('id')&#10;&#10;                # Only process SMS options&#10;                if not radio_id or not radio_id.startswith('send_sms:'):&#10;                    continue&#10;&#10;                # Find the label associated with this radio button&#10;                label = self.driver.find_element(By.XPATH, f&quot;//label[@for='{radio_id}']&quot;)&#10;                label_text = label.text&#10;&#10;                # Check if it contains &quot;Send code via SMS&quot;&#10;                if &quot;Send code via SMS&quot; not in label_text:&#10;                    continue&#10;&#10;                # Extract phone number from the label (it's in the second div)&#10;                phone_in_label = ''.join(filter(str.isdigit, label_text))&#10;&#10;                # Match the phone number - look for full match or partial match&#10;                # The phone number appears after &quot;Send code via SMS&quot; text&#10;                if phone_to_match == phone_in_label or phone_to_match in phone_in_label or phone_in_label in phone_to_match:&#10;                    # Check if this is NOT a masked number (masked numbers have asterisks)&#10;                    if '*' not in label_text or phone_to_match in label_text.replace('+', ''):&#10;                        sms_radio_to_click = radio&#10;                        break&#10;            except Exception as e:&#10;                logger.debug(f&quot;Error processing radio button: {e}&quot;)&#10;                continue&#10;&#10;        if not sms_radio_to_click:&#10;            # No SMS option found - set error and stop&#10;            self.continuation = False&#10;            self.error_message = &quot;Can't find the 'Send code via SMS' option.&quot;&#10;            logger.info(&quot;SMS verification option not available for this account&quot;)&#10;            return&#10;&#10;        if not sms_radio_to_click.is_selected():&#10;            sms_radio_to_click.click()&#10;            logger.info(&quot;SMS radio button clicked&quot;)&#10;&#10;        continue_button = self.wait.until(&#10;            EC.element_to_be_clickable((By.XPATH, &quot;//button[@name='reset_action' and @type='submit' and contains(text(), 'Continue')]&quot;))&#10;        )&#10;        continue_button.click()&#10;        logger.info(&quot;SMS code option selected and Continue clicked&quot;)&#10;&#10;    def continue_phone_number(self):&#10;        pass&#10;&#10;    def on_disabled(self):&#10;        self.continuation = False&#10;        self.error_message = &quot;Account is disabled&quot;&#10;        logger.info(&quot;Account is disabled&quot;)&#10;&#10;    def on_verification_send(self):&#10;        self.continuation = False&#10;        self.reached_success = True  # Set flag when verification code page is reached&#10;        logger.info(&quot;Verification code input page reached&quot;)&#10;&#10;    def no_search_results(self):&#10;        self.continuation = False&#10;        self.error_message = &quot;Facebook account isn't found&quot;&#10;        logger.info(&quot;Facebook account isn't found&quot;)&#10;&#10;    def on_robot_detected(self):&#10;        self.continuation = False&#10;        self.error_message = &quot;Robot detected - CAPTCHA required&quot;&#10;        logger.info(&quot;Robot detected&quot;)&#10;&#10;    def try_another_way(self):&#10;        try:&#10;            try_another_way_button = self.wait.until(&#10;                EC.element_to_be_clickable((By.XPATH, &quot;//a[@name='tryanotherway' and contains(text(), 'Try another way')]&quot;))&#10;            )&#10;            try_another_way_button.click()&#10;            logger.info(&quot;Clicked 'Try another way' button&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error clicking 'Try another way' button: {e}&quot;)&#10;            # Try alternative selector&#10;            try:&#10;                try_another_way_button = self.wait.until(&#10;                    EC.element_to_be_clickable((By.NAME, &quot;tryanotherway&quot;))&#10;                )&#10;                try_another_way_button.click()&#10;                logger.info(&quot;Clicked 'Try another way' button using alternative selector&quot;)&#10;            except Exception as e2:&#10;                logger.error(f&quot;Failed with alternative selector too: {e2}&quot;)&#10;                raise&#10;&#10;    def reload_page(self):&#10;        self.driver.refresh()&#10;&#10;    def direct_code_send(self):&#10;        &quot;&quot;&quot;Handle the case where Facebook directly offers to send a code to the phone number&quot;&quot;&quot;&#10;        try:&#10;            # Click the Continue button to send the verification code&#10;            continue_button = self.wait.until(&#10;                EC.element_to_be_clickable((By.XPATH, &quot;//button[@type='submit' and contains(text(), 'Continue')]&quot;))&#10;            )&#10;            continue_button.click()&#10;            logger.info(&quot;Clicked Continue button to send verification code directly&quot;)&#10;        except Exception as e:&#10;            logger.error(f&quot;Error clicking Continue button: {e}&quot;)&#10;            # Try alternative selector&#10;            try:&#10;                continue_button = self.wait.until(&#10;                    EC.element_to_be_clickable((By.XPATH, &quot;//button[@type='submit']&quot;))&#10;                )&#10;                continue_button.click()&#10;                logger.info(&quot;Clicked Continue button using alternative selector&quot;)&#10;            except Exception as e2:&#10;                logger.error(f&quot;Failed with alternative selector too: {e2}&quot;)&#10;                raise&#10;&#10;    def handle_continuation(self):&#10;        try:&#10;            text_actions = {&#10;                &quot;These accounts matched your search&quot;: self.select_account,&#10;                &quot;How do you want to receive the code to reset your password?&quot;: self.continue_send_code,&#10;                &quot;How do you want to get the code to reset your password?&quot;: self.continue_send_code,&#10;                &quot;Before we send the code, enter these letters and numbers&quot;: self.on_robot_detected,&#10;                &quot;Enter security code&quot;: self.on_verification_send,&#10;                &quot;Account disabled&quot;: self.on_disabled,&#10;                &quot;No search results&quot;: self.no_search_results,&#10;                &quot;Log in as&quot;: self.try_another_way,&#10;                &quot;Log in to&quot;: self.try_another_way,&#10;                &quot;Reload page&quot;: self.reload_page,&#10;                &quot;We can send a login code to:&quot;: self.direct_code_send,&#10;            }&#10;&#10;            while self.continuation:&#10;                found_text = self.wait_for_text_and_execute(text_actions)&#10;&#10;                if not found_text:&#10;                    logger.warning(&quot;No expected text found&quot;)&#10;                    break&#10;&#10;                # Strict mode: remove the executed text action from the map&#10;                if found_text in text_actions:&#10;                    del text_actions[found_text]&#10;&#10;                # If all actions are exhausted, break&#10;                if not text_actions:&#10;                    break&#10;&#10;        except Exception as e:&#10;            logger.error(f&quot;An error occurred: {e}&quot;)&#10;            raise&#10;&#10;&#10;    def page_preview(self):&#10;        screenshot_bytes = self.driver.get_screenshot_as_png()&#10;        image = Image.open(BytesIO(screenshot_bytes))&#10;        image.show()&#10;        logger.info(&quot;Screenshot preview opened&quot;)&#10;&#10;    def close(self):&#10;        if self.driver:&#10;            # Get final bandwidth statistics before closing&#10;            self.update_bandwidth_stats()&#10;&#10;            # Log per-session bandwidth usage&#10;            total_bandwidth = self.bandwidth_stats['bytes_sent'] + self.bandwidth_stats['bytes_received']&#10;            logger.info(f&quot;Bandwidth for this check: Sent={self.format_bytes(self.bandwidth_stats['bytes_sent'])}, &quot;&#10;                       f&quot;Received={self.format_bytes(self.bandwidth_stats['bytes_received'])}, &quot;&#10;                       f&quot;Total={self.format_bytes(total_bandwidth)}, &quot;&#10;                       f&quot;Requests={self.bandwidth_stats['requests_count']}&quot;)&#10;&#10;            # Update global bandwidth statistics&#10;            with _total_bandwidth_lock:&#10;                _global_bandwidth_stats['total_sent'] += self.bandwidth_stats['bytes_sent']&#10;                _global_bandwidth_stats['total_received'] += self.bandwidth_stats['bytes_received']&#10;                _global_bandwidth_stats['total_requests'] += self.bandwidth_stats['requests_count']&#10;&#10;            self.driver.quit()&#10;            logger.info(&quot;Browser closed&quot;)&#10;&#10;    def check_number(self, phone_number):&#10;        &quot;&quot;&quot;&#10;        Check a single phone number and return the result&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.search_phone_number(phone_number)&#10;            self.handle_continuation()&#10;&#10;            # Check if verification page was reached successfully&#10;            if self.reached_success:&#10;                return {&#10;                    'phone': phone_number,&#10;                    'status': 'success',&#10;                    'message': 'Verification code page reached'&#10;                }&#10;            # If we have a specific error message, return it&#10;            elif self.error_message:&#10;                return {&#10;                    'phone': phone_number,&#10;                    'status': 'failed',&#10;                    'message': self.error_message&#10;                }&#10;            # Otherwise, return unknown error&#10;            else:&#10;                return {&#10;                    'phone': phone_number,&#10;                    'status': 'failed',&#10;                    'message': 'Unknown error - didn\'t reach verification page'&#10;                }&#10;        except Exception as e:&#10;            logger.error(f&quot;Error checking {phone_number}: {e}&quot;)&#10;            return {&#10;                'phone': phone_number,&#10;                'status': 'error',&#10;                'message': str(e)&#10;            }&#10;&#10;&#10;def check_single_number(phone_number):&#10;    &quot;&quot;&quot;&#10;    Worker function to check a single phone number&#10;    &quot;&quot;&quot;&#10;    checker = FacebookNumberChecker(headless=False)&#10;    try:&#10;        checker.setup_driver()&#10;        result = checker.check_number(phone_number)&#10;        logger.info(f&quot;Completed check for {phone_number}: {result['status']}&quot;)&#10;        return result&#10;    except Exception as e:&#10;        logger.error(f&quot;Worker error for {phone_number}: {e}&quot;)&#10;        return {&#10;            'phone': phone_number,&#10;            'status': 'error',&#10;            'message': str(e)&#10;        }&#10;    finally:&#10;        checker.close()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    #&#10;    # nums = [&#10;    #     &quot;2250708139166&quot;, &quot;2250708135432&quot;, &quot;2250708136329&quot;, &quot;2250708137946&quot;, &quot;2250708130149&quot;, &quot;2250708132325&quot;,&#10;    #     &quot;2250708134921&quot;, &quot;2250708131254&quot;, &quot;2250708135326&quot;, &quot;2250708136921&quot;, &quot;2250708138627&quot;, &quot;2250708136804&quot;,&#10;    #     &quot;2250708133468&quot;, &quot;2250708130814&quot;, &quot;2250708132680&quot;, &quot;2250708131009&quot;, &quot;2250708136508&quot;, &quot;2250708135640&quot;,&#10;    #     &quot;2250708136254&quot;, &quot;2250708137888&quot;, &quot;2250708130404&quot;, &quot;2250708132032&quot;, &quot;2250708135700&quot;, &quot;2250708136514&quot;,&#10;    #     &quot;2250708133330&quot;, &quot;2250708137507&quot;, &quot;2250708131688&quot;, &quot;2250708132191&quot;, &quot;2250708134184&quot;, &quot;2250708135392&quot;,&#10;    #     &quot;2250708135811&quot;, &quot;2250708131936&quot;, &quot;2250708138942&quot;, &quot;2250708130543&quot;, &quot;2250708134441&quot;, &quot;2250708139822&quot;,&#10;    #     &quot;2250708133494&quot;, &quot;2250708131958&quot;, &quot;2250708130684&quot;, &quot;2250708136616&quot;, &quot;2250708130337&quot;, &quot;2250708131019&quot;,&#10;    #     &quot;2250708130369&quot;, &quot;2250708137183&quot;, &quot;2250708130469&quot;, &quot;2250708134024&quot;, &quot;2250708133098&quot;, &quot;2250708135786&quot;,&#10;    #     &quot;2250708131322&quot;, &quot;2250708138204&quot;, &quot;2250708139499&quot;, &quot;2250708138352&quot;, &quot;2250708134979&quot;, &quot;2250708139512&quot;,&#10;    #     &quot;2250708132538&quot;, &quot;2250708136979&quot;, &quot;2250708136863&quot;, &quot;2250708136665&quot;, &quot;2250708131689&quot;, &quot;2250708138575&quot;,&#10;    #     &quot;2250708134924&quot;, &quot;2250708130984&quot;, &quot;2250708138875&quot;, &quot;2250708131727&quot;, &quot;2250708136283&quot;, &quot;2250708132332&quot;,&#10;    #     &quot;2250708132646&quot;, &quot;2250708135113&quot;, &quot;2250708139954&quot;, &quot;2250708132201&quot;, &quot;2250708136558&quot;, &quot;2250708134414&quot;,&#10;    #     &quot;2250708131519&quot;, &quot;2250708135538&quot;, &quot;2250708130197&quot;, &quot;2250708131851&quot;, &quot;2250708133530&quot;, &quot;2250708130279&quot;,&#10;    #     &quot;2250708132252&quot;, &quot;2250708135809&quot;, &quot;2250708138185&quot;, &quot;2250708138513&quot;, &quot;2250708139799&quot;, &quot;2250708130520&quot;,&#10;    #     &quot;2250708138986&quot;, &quot;2250708133287&quot;, &quot;2250708134147&quot;, &quot;2250708131345&quot;, &quot;2250708131565&quot;, &quot;2250708132120&quot;,&#10;    #     &quot;2250708131610&quot;, &quot;2250708132501&quot;, &quot;2250708139948&quot;, &quot;2250708138734&quot;, &quot;2250708136500&quot;, &quot;2250708130826&quot;,&#10;    #     &quot;2250708138855&quot;, &quot;2250708139632&quot;, &quot;2250708136711&quot;, &quot;2250708136905&quot;&#10;    # ]&#10;&#10;    nums = [&#10;        &quot;2250708139166&quot;&#10;    ]&#10;&#10;    results = []&#10;&#10;    logger.info(f&quot;Starting to check {len(nums)} phone numbers with 5 concurrent workers&quot;)&#10;&#10;    with ThreadPoolExecutor(max_workers=1) as executor:&#10;        # Submit all tasks&#10;        future_to_phone = {executor.submit(check_single_number, phone): phone for phone in nums}&#10;&#10;        # Process completed tasks as they finish&#10;        for future in as_completed(future_to_phone):&#10;            phone = future_to_phone[future]&#10;            try:&#10;                result = future.result()&#10;                results.append(result)&#10;                logger.info(f&quot;Progress: {len(results)}/{len(nums)} completed&quot;)&#10;            except Exception as e:&#10;                logger.error(f&quot;Exception for {phone}: {e}&quot;)&#10;                results.append({&#10;                    'phone': phone,&#10;                    'status': 'error',&#10;                    'message': str(e)&#10;                })&#10;&#10;    # Print summary&#10;    logger.info(&quot;=&quot; * 50)&#10;    logger.info(&quot;FINAL RESULTS:&quot;)&#10;    logger.info(&quot;=&quot; * 50)&#10;&#10;    success_count = sum(1 for r in results if r['status'] == 'success')&#10;    error_count = sum(1 for r in results if r['status'] == 'error')&#10;&#10;    logger.info(f&quot;Total checked: {len(results)}&quot;)&#10;    logger.info(f&quot;Successful: {success_count}&quot;)&#10;    logger.info(f&quot;Errors: {error_count}&quot;)&#10;&#10;    logger.info(&quot;\nDetailed results:&quot;)&#10;    for result in results:&#10;        logger.info(f&quot;{result['phone']}: {result['status']} - {result['message']}&quot;)&#10;&#10;    # Print total bandwidth usage&#10;    logger.info(&quot;=&quot; * 50)&#10;    logger.info(&quot;TOTAL BANDWIDTH USAGE:&quot;)&#10;    logger.info(&quot;=&quot; * 50)&#10;    total_sent = _global_bandwidth_stats['total_sent']&#10;    total_received = _global_bandwidth_stats['total_received']&#10;    total_bandwidth = total_sent + total_received&#10;    total_requests = _global_bandwidth_stats['total_requests']&#10;&#10;    logger.info(f&quot;Total Sent: {FacebookNumberChecker.format_bytes(total_sent)}&quot;)&#10;    logger.info(f&quot;Total Received: {FacebookNumberChecker.format_bytes(total_received)}&quot;)&#10;    logger.info(f&quot;Total Bandwidth: {FacebookNumberChecker.format_bytes(total_bandwidth)}&quot;)&#10;    logger.info(f&quot;Total Requests: {total_requests}&quot;)&#10;&#10;    if len(results) &gt; 0:&#10;        avg_bandwidth_per_check = total_bandwidth / len(results)&#10;        logger.info(f&quot;Average Bandwidth per Check: {FacebookNumberChecker.format_bytes(avg_bandwidth_per_check)}&quot;)&#10;&#10;    logger.info(&quot;=&quot; * 50)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>