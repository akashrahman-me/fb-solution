<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/proxy_injector.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/proxy_injector.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Simple HTTP proxy that forwards requests to an upstream authenticated proxy.&#10;&quot;&quot;&quot;&#10;import socket&#10;import select&#10;import threading&#10;import base64&#10;import re&#10;from urllib.parse import urlparse&#10;from http.server import HTTPServer, BaseHTTPRequestHandler&#10;import json&#10;from datetime import datetime&#10;&#10;# --- Configuration ---&#10;LOCAL_PROXY_HOST = &quot;127.0.0.1&quot;&#10;LOCAL_PROXY_PORT = 8080&#10;STATS_SERVER_PORT = 8081&#10;&#10;# Residential Proxy Credentials&#10;# ---------------------&#10;REMOTE_SERVER = &quot;aus.360s5.com&quot;&#10;REMOTE_PORT = 3600&#10;REMOTE_USERNAME = &quot;75072370-zone-custom-region-KG&quot;&#10;REMOTE_PASSWORD = &quot;G8Vmo6ac&quot;&#10;# Residential Proxy Credentials&#10;# ---------------------&#10;# REMOTE_SERVER = &quot;aus.360s5.com&quot;&#10;# REMOTE_PORT = 3600&#10;# REMOTE_USERNAME = &quot;75072370-zone-custom&quot;&#10;# REMOTE_PASSWORD = &quot;G8Vmo6ac&quot;&#10;&#10;# Datacenter Proxy Credentials&#10;# ---------------------&#10;# REMOTE_SERVER = &quot;142.111.48.253&quot;&#10;# REMOTE_PORT = 7030&#10;# REMOTE_USERNAME = &quot;lmmwyrac&quot;&#10;# REMOTE_PASSWORD = &quot;fi17jsine73g&quot;&#10;# ---------------------&#10;&#10;# Base64 encode the credentials&#10;PROXY_AUTH = base64.b64encode(f&quot;{REMOTE_USERNAME}:{REMOTE_PASSWORD}&quot;.encode()).decode()&#10;&#10;# Global statistics&#10;class ProxyStats:&#10;    def __init__(self):&#10;        self.total_sent = 0&#10;        self.total_received = 0&#10;        self.total_requests = 0&#10;        self.start_time = datetime.now()&#10;        self.lock = threading.Lock()&#10;&#10;    def add_request(self, sent, received):&#10;        with self.lock:&#10;            self.total_sent += sent&#10;            self.total_received += received&#10;            self.total_requests += 1&#10;&#10;    def get_stats(self):&#10;        with self.lock:&#10;            return {&#10;                'total_sent': self.total_sent,&#10;                'total_received': self.total_received,&#10;                'total_data': self.total_sent + self.total_received,&#10;                'total_requests': self.total_requests,&#10;                'uptime_seconds': (datetime.now() - self.start_time).total_seconds()&#10;            }&#10;&#10;stats = ProxyStats()&#10;&#10;class StatsHandler(BaseHTTPRequestHandler):&#10;    def log_message(self, format, *args):&#10;        # Suppress default logging&#10;        pass&#10;&#10;    def do_GET(self):&#10;        if self.path == '/stats' or self.path == '/':&#10;            data = stats.get_stats()&#10;&#10;            # Format bytes&#10;            def format_bytes(b):&#10;                if b &gt;= 1024 * 1024 * 1024:&#10;                    return f&quot;{b / (1024 * 1024 * 1024):.2f} GB&quot;&#10;                elif b &gt;= 1024 * 1024:&#10;                    return f&quot;{b / (1024 * 1024):.2f} MB&quot;&#10;                elif b &gt;= 1024:&#10;                    return f&quot;{b / 1024:.2f} KB&quot;&#10;                else:&#10;                    return f&quot;{b} B&quot;&#10;&#10;            uptime_minutes = int(data['uptime_seconds'] / 60)&#10;            uptime_hours = int(uptime_minutes / 60)&#10;            uptime_minutes = uptime_minutes % 60&#10;&#10;            html = f&quot;&quot;&quot;&#10;            &lt;!DOCTYPE html&gt;&#10;            &lt;html&gt;&#10;            &lt;head&gt;&#10;                &lt;title&gt;Proxy Stats&lt;/title&gt;&#10;                &lt;meta charset=&quot;utf-8&quot;&gt;&#10;                &lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot;&gt;&#10;                &lt;style&gt;&#10;                    body {{&#10;                        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;&#10;                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);&#10;                        margin: 0;&#10;                        padding: 20px;&#10;                        display: flex;&#10;                        justify-content: center;&#10;                        align-items: center;&#10;                        min-height: 100vh;&#10;                    }}&#10;                    .container {{&#10;                        background: white;&#10;                        border-radius: 15px;&#10;                        box-shadow: 0 10px 40px rgba(0,0,0,0.2);&#10;                        padding: 40px;&#10;                        max-width: 600px;&#10;                        width: 100%;&#10;                    }}&#10;                    h1 {{&#10;                        color: #333;&#10;                        margin-top: 0;&#10;                        text-align: center;&#10;                        font-size: 2em;&#10;                    }}&#10;                    .stat-box {{&#10;                        background: #f8f9fa;&#10;                        border-left: 4px solid #667eea;&#10;                        padding: 20px;&#10;                        margin: 15px 0;&#10;                        border-radius: 5px;&#10;                    }}&#10;                    .stat-label {{&#10;                        color: #666;&#10;                        font-size: 0.9em;&#10;                        text-transform: uppercase;&#10;                        letter-spacing: 1px;&#10;                        margin-bottom: 5px;&#10;                    }}&#10;                    .stat-value {{&#10;                        color: #333;&#10;                        font-size: 1.8em;&#10;                        font-weight: bold;&#10;                    }}&#10;                    .total {{&#10;                        border-left-color: #28a745;&#10;                    }}&#10;                    .upload {{&#10;                        border-left-color: #ffc107;&#10;                    }}&#10;                    .download {{&#10;                        border-left-color: #17a2b8;&#10;                    }}&#10;                    .info {{&#10;                        text-align: center;&#10;                        color: #666;&#10;                        margin-top: 30px;&#10;                        font-size: 0.9em;&#10;                    }}&#10;                    .emoji {{&#10;                        font-size: 1.2em;&#10;                        margin-right: 5px;&#10;                    }}&#10;                &lt;/style&gt;&#10;            &lt;/head&gt;&#10;            &lt;body&gt;&#10;                &lt;div class=&quot;container&quot;&gt;&#10;                    &lt;h1&gt; Proxy Statistics&lt;/h1&gt;&#10;                    &#10;                    &lt;div class=&quot;stat-box total&quot;&gt;&#10;                        &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;✅&lt;/span&gt;Total Data&lt;/div&gt;&#10;                        &lt;div class=&quot;stat-value&quot;&gt;{format_bytes(data['total_data'])}&lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;div class=&quot;stat-box upload&quot;&gt;&#10;                        &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;⬆️&lt;/span&gt;Total Uploaded&lt;/div&gt;&#10;                        &lt;div class=&quot;stat-value&quot;&gt;{format_bytes(data['total_sent'])}&lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;div class=&quot;stat-box download&quot;&gt;&#10;                        &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;⬇️&lt;/span&gt;Total Downloaded&lt;/div&gt;&#10;                        &lt;div class=&quot;stat-value&quot;&gt;{format_bytes(data['total_received'])}&lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;div class=&quot;stat-box&quot;&gt;&#10;                        &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;&lt;/span&gt;Total Requests&lt;/div&gt;&#10;                        &lt;div class=&quot;stat-value&quot;&gt;{data['total_requests']:,}&lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;div class=&quot;stat-box&quot;&gt;&#10;                        &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;⏱️&lt;/span&gt;Uptime&lt;/div&gt;&#10;                        &lt;div class=&quot;stat-value&quot;&gt;{uptime_hours}h {uptime_minutes}m&lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;div class=&quot;info&quot;&gt;&#10;                        Auto-refreshes every 5 seconds&lt;br&gt;&#10;                        Stats Server: http://localhost:{STATS_SERVER_PORT}/stats&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/body&gt;&#10;            &lt;/html&gt;&#10;            &quot;&quot;&quot;&#10;&#10;            self.send_response(200)&#10;            self.send_header('Content-type', 'text/html; charset=utf-8')&#10;            self.end_headers()&#10;            self.wfile.write(html.encode('utf-8'))&#10;&#10;        elif self.path == '/json':&#10;            data = stats.get_stats()&#10;            self.send_response(200)&#10;            self.send_header('Content-type', 'application/json')&#10;            self.end_headers()&#10;            self.wfile.write(json.dumps(data, indent=2).encode())&#10;&#10;        else:&#10;            self.send_response(404)&#10;            self.end_headers()&#10;&#10;def start_stats_server():&#10;    &quot;&quot;&quot;Start the stats HTTP server&quot;&quot;&quot;&#10;    server = HTTPServer((LOCAL_PROXY_HOST, STATS_SERVER_PORT), StatsHandler)&#10;    print(f&quot;✓ Stats server started on http://{LOCAL_PROXY_HOST}:{STATS_SERVER_PORT}/stats&quot;)&#10;    server.serve_forever()&#10;&#10;class ProxyThread(threading.Thread):&#10;    def __init__(self, client_socket, client_address):&#10;        threading.Thread.__init__(self)&#10;        self.client = client_socket&#10;        self.client_address = client_address&#10;        self.daemon = True&#10;        self.bytes_sent = 0&#10;        self.bytes_received = 0&#10;        self.url = &quot;&quot;&#10;&#10;    def run(self):&#10;        try:&#10;            # Receive the client's request&#10;            request = self.client.recv(4096)&#10;            if not request:&#10;                return&#10;&#10;            request_str = request.decode('latin-1', errors='ignore')&#10;&#10;            # Extract URL from request&#10;            self.url = self.extract_url(request_str)&#10;            self.bytes_sent += len(request)&#10;&#10;            # Add Proxy-Authorization header if not present&#10;            lines = request_str.split('\r\n')&#10;            has_proxy_auth = any('Proxy-Authorization' in line for line in lines)&#10;            &#10;            if not has_proxy_auth:&#10;                # Insert Proxy-Authorization after the first line&#10;                lines.insert(1, f'Proxy-Authorization: Basic {PROXY_AUTH}')&#10;                request_str = '\r\n'.join(lines)&#10;                request = request_str.encode('latin-1')&#10;&#10;            # Connect to the upstream proxy&#10;            upstream = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#10;            upstream.settimeout(10)&#10;            &#10;            try:&#10;                upstream.connect((REMOTE_SERVER, REMOTE_PORT))&#10;                &#10;                # Send the modified request to upstream proxy&#10;                upstream.sendall(request)&#10;                &#10;                # Relay data between client and upstream proxy&#10;                self.relay_data(self.client, upstream)&#10;                &#10;            except socket.timeout:&#10;                self.client.send(b&quot;HTTP/1.1 504 Gateway Timeout\r\n\r\n&quot;)&#10;            except ConnectionRefusedError:&#10;                self.client.send(b&quot;HTTP/1.1 502 Bad Gateway\r\n\r\n&quot;)&#10;            except Exception as e:&#10;                self.client.send(b&quot;HTTP/1.1 502 Bad Gateway\r\n\r\n&quot;)&#10;            finally:&#10;                upstream.close()&#10;                &#10;        except Exception as e:&#10;            pass&#10;        finally:&#10;            self.client.close()&#10;            self.print_stats()&#10;&#10;    def extract_url(self, request_str):&#10;        &quot;&quot;&quot;Extract URL from HTTP request&quot;&quot;&quot;&#10;        try:&#10;            lines = request_str.split('\r\n')&#10;            if lines:&#10;                first_line = lines[0]&#10;                parts = first_line.split(' ')&#10;                if len(parts) &gt;= 2:&#10;                    method = parts[0]&#10;                    url = parts[1]&#10;&#10;                    # If it's a CONNECT request (HTTPS), format it&#10;                    if method == 'CONNECT':&#10;                        return f&quot;https://{url}&quot;&#10;                    # If URL is absolute, use it&#10;                    elif url.startswith('http'):&#10;                        return url&#10;                    # Otherwise, try to find Host header&#10;                    else:&#10;                        for line in lines[1:]:&#10;                            if line.lower().startswith('host:'):&#10;                                host = line.split(':', 1)[1].strip()&#10;                                return f&quot;http://{host}{url}&quot;&#10;                        return url&#10;        except:&#10;            pass&#10;        return &quot;unknown&quot;&#10;&#10;    def format_bytes(self, bytes_count):&#10;        &quot;&quot;&quot;Format bytes to appropriate unit (Bytes, KB, or MB)&quot;&quot;&quot;&#10;        if bytes_count &gt;= 1024 * 1024:  # &gt;= 1MB&#10;            return f&quot;{bytes_count / (1024 * 1024):.1f}MB&quot;&#10;        elif bytes_count &gt;= 1024:  # &gt;= 1KB&#10;            return f&quot;{bytes_count / 1024:.1f}KB&quot;&#10;        else:  # &lt; 1KB&#10;            return f&quot;{bytes_count}B&quot;&#10;&#10;    def print_stats(self):&#10;        &quot;&quot;&quot;Print transfer statistics&quot;&quot;&quot;&#10;        total = self.bytes_sent + self.bytes_received&#10;        if total &gt; 0:&#10;            # Update global stats&#10;            stats.add_request(self.bytes_sent, self.bytes_received)&#10;            print(f&quot; {self.url} | ⬆️ {self.format_bytes(self.bytes_sent)} | ⬇️ {self.format_bytes(self.bytes_received)} | ✅ {self.format_bytes(total)}&quot;)&#10;&#10;    def relay_data(self, client, upstream):&#10;        &quot;&quot;&quot;Relay data between client and upstream proxy&quot;&quot;&quot;&#10;        try:&#10;            sockets = [client, upstream]&#10;            timeout = 60&#10;            &#10;            while True:&#10;                readable, _, exceptional = select.select(sockets, [], sockets, timeout)&#10;                &#10;                if exceptional:&#10;                    break&#10;                    &#10;                if not readable:&#10;                    break&#10;                &#10;                for sock in readable:&#10;                    try:&#10;                        data = sock.recv(8192)&#10;                        if not data:&#10;                            return&#10;                        &#10;                        if sock is client:&#10;                            upstream.send(data)&#10;                            self.bytes_sent += len(data)&#10;                        else:&#10;                            client.send(data)&#10;                            self.bytes_received += len(data)&#10;                    except:&#10;                        return&#10;                        &#10;        except Exception as e:&#10;            pass&#10;&#10;&#10;def start_proxy_server():&#10;    &quot;&quot;&quot;Start the local proxy server&quot;&quot;&quot;&#10;    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#10;    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)&#10;    &#10;    try:&#10;        server.bind((LOCAL_PROXY_HOST, LOCAL_PROXY_PORT))&#10;        server.listen(100)&#10;        &#10;        print(f&quot;✓ Proxy server started on {LOCAL_PROXY_HOST}:{LOCAL_PROXY_PORT}&quot;)&#10;        print(f&quot;✓ Forwarding to: {REMOTE_SERVER}:{REMOTE_PORT}&quot;)&#10;&#10;        # Start stats server in a separate thread&#10;        stats_thread = threading.Thread(target=start_stats_server, daemon=True)&#10;        stats_thread.start()&#10;&#10;        print(f&quot;✓ Press Ctrl+C to stop\n&quot;)&#10;        &#10;        while True:&#10;            client_socket, client_address = server.accept()&#10;            proxy_thread = ProxyThread(client_socket, client_address)&#10;            proxy_thread.start()&#10;            &#10;    except KeyboardInterrupt:&#10;        print(&quot;\n\nShutting down proxy server...&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error starting proxy server: {e}&quot;)&#10;    finally:&#10;        server.close()&#10;        print(&quot;Proxy server stopped.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    start_proxy_server()&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Simple HTTP proxy that forwards requests to an upstream authenticated proxy.&#10;&quot;&quot;&quot;&#10;import socket&#10;import select&#10;import threading&#10;import base64&#10;import re&#10;from urllib.parse import urlparse&#10;from http.server import HTTPServer, BaseHTTPRequestHandler&#10;import json&#10;from datetime import datetime&#10;from collections import deque&#10;&#10;# --- Configuration ---&#10;LOCAL_PROXY_HOST = &quot;127.0.0.1&quot;&#10;LOCAL_PROXY_PORT = 8080&#10;STATS_SERVER_PORT = 8081&#10;&#10;# Residential Proxy Credentials&#10;# ---------------------&#10;REMOTE_SERVER = &quot;aus.360s5.com&quot;&#10;REMOTE_PORT = 3600&#10;REMOTE_USERNAME = &quot;75072370-zone-custom-region-KG&quot;&#10;REMOTE_PASSWORD = &quot;G8Vmo6ac&quot;&#10;# Residential Proxy Credentials&#10;# ---------------------&#10;# REMOTE_SERVER = &quot;aus.360s5.com&quot;&#10;# REMOTE_PORT = 3600&#10;# REMOTE_USERNAME = &quot;75072370-zone-custom&quot;&#10;# REMOTE_PASSWORD = &quot;G8Vmo6ac&quot;&#10;&#10;# Datacenter Proxy Credentials&#10;# ---------------------&#10;# REMOTE_SERVER = &quot;142.111.48.253&quot;&#10;# REMOTE_PORT = 7030&#10;# REMOTE_USERNAME = &quot;lmmwyrac&quot;&#10;# REMOTE_PASSWORD = &quot;fi17jsine73g&quot;&#10;# ---------------------&#10;&#10;# Base64 encode the credentials&#10;PROXY_AUTH = base64.b64encode(f&quot;{REMOTE_USERNAME}:{REMOTE_PASSWORD}&quot;.encode()).decode()&#10;&#10;# Global statistics&#10;class ProxyStats:&#10;    def __init__(self):&#10;        self.total_sent = 0&#10;        self.total_received = 0&#10;        self.total_requests = 0&#10;        self.start_time = datetime.now()&#10;        self.lock = threading.Lock()&#10;        self.logs = deque(maxlen=100)  # Keep last 100 requests&#10;&#10;    def add_request(self, sent, received, url=&quot;&quot;):&#10;        with self.lock:&#10;            self.total_sent += sent&#10;            self.total_received += received&#10;            self.total_requests += 1&#10;            # Add log entry&#10;            self.logs.append({&#10;                'timestamp': datetime.now().strftime('%H:%M:%S'),&#10;                'url': url,&#10;                'sent': sent,&#10;                'received': received,&#10;                'total': sent + received&#10;            })&#10;&#10;    def get_stats(self):&#10;        with self.lock:&#10;            return {&#10;                'total_sent': self.total_sent,&#10;                'total_received': self.total_received,&#10;                'total_data': self.total_sent + self.total_received,&#10;                'total_requests': self.total_requests,&#10;                'uptime_seconds': (datetime.now() - self.start_time).total_seconds()&#10;            }&#10;    &#10;    def get_logs(self):&#10;        with self.lock:&#10;            return list(self.logs)&#10;&#10;stats = ProxyStats()&#10;&#10;class StatsHandler(BaseHTTPRequestHandler):&#10;    def log_message(self, format, *args):&#10;        # Suppress default logging&#10;        pass&#10;&#10;    def do_GET(self):&#10;        if self.path == '/stats' or self.path == '/':&#10;            data = stats.get_stats()&#10;            logs = stats.get_logs()&#10;&#10;            # Format bytes&#10;            def format_bytes(b):&#10;                if b &gt;= 1024 * 1024 * 1024:&#10;                    return f&quot;{b / (1024 * 1024 * 1024):.2f} GB&quot;&#10;                elif b &gt;= 1024 * 1024:&#10;                    return f&quot;{b / (1024 * 1024):.2f} MB&quot;&#10;                elif b &gt;= 1024:&#10;                    return f&quot;{b / 1024:.1f} KB&quot;&#10;                else:&#10;                    return f&quot;{b} B&quot;&#10;&#10;            uptime_minutes = int(data['uptime_seconds'] / 60)&#10;            uptime_hours = int(uptime_minutes / 60)&#10;            uptime_minutes = uptime_minutes % 60&#10;            &#10;            # Generate log entries HTML&#10;            log_entries = &quot;&quot;&#10;            for log in reversed(logs):  # Show newest first&#10;                log_entries += f&quot;&quot;&quot;&#10;                    &lt;div class=&quot;log-entry&quot;&gt;&#10;                        &lt;span class=&quot;log-time&quot;&gt;{log['timestamp']}&lt;/span&gt;&#10;                        &lt;span class=&quot;log-url&quot;&gt; {log['url']}&lt;/span&gt;&#10;                        &lt;span class=&quot;log-stats&quot;&gt;&#10;                            &lt;span class=&quot;log-upload&quot;&gt;⬆️ {format_bytes(log['sent'])}&lt;/span&gt;&#10;                            &lt;span class=&quot;log-download&quot;&gt;⬇️ {format_bytes(log['received'])}&lt;/span&gt;&#10;                            &lt;span class=&quot;log-total&quot;&gt;✅ {format_bytes(log['total'])}&lt;/span&gt;&#10;                        &lt;/span&gt;&#10;                    &lt;/div&gt;&#10;                &quot;&quot;&quot;&#10;&#10;            html = f&quot;&quot;&quot;&#10;            &lt;!DOCTYPE html&gt;&#10;            &lt;html&gt;&#10;            &lt;head&gt;&#10;                &lt;title&gt;Proxy Stats&lt;/title&gt;&#10;                &lt;meta charset=&quot;utf-8&quot;&gt;&#10;                &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3&quot;&gt;&#10;                &lt;style&gt;&#10;                    * {{&#10;                        box-sizing: border-box;&#10;                    }}&#10;                    body {{&#10;                        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;&#10;                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);&#10;                        margin: 0;&#10;                        padding: 20px;&#10;                        min-height: 100vh;&#10;                    }}&#10;                    .wrapper {{&#10;                        max-width: 1400px;&#10;                        margin: 0 auto;&#10;                        display: grid;&#10;                        grid-template-columns: 1fr 1fr;&#10;                        gap: 20px;&#10;                    }}&#10;                    .container {{&#10;                        background: white;&#10;                        border-radius: 15px;&#10;                        box-shadow: 0 10px 40px rgba(0,0,0,0.2);&#10;                        padding: 30px;&#10;                    }}&#10;                    .full-width {{&#10;                        grid-column: 1 / -1;&#10;                    }}&#10;                    h1 {{&#10;                        color: #333;&#10;                        margin-top: 0;&#10;                        text-align: center;&#10;                        font-size: 2em;&#10;                        margin-bottom: 20px;&#10;                    }}&#10;                    h2 {{&#10;                        color: #333;&#10;                        margin-top: 0;&#10;                        font-size: 1.5em;&#10;                        margin-bottom: 15px;&#10;                        border-bottom: 2px solid #667eea;&#10;                        padding-bottom: 10px;&#10;                    }}&#10;                    .stat-box {{&#10;                        background: #f8f9fa;&#10;                        border-left: 4px solid #667eea;&#10;                        padding: 15px 20px;&#10;                        margin: 10px 0;&#10;                        border-radius: 5px;&#10;                    }}&#10;                    .stat-label {{&#10;                        color: #666;&#10;                        font-size: 0.85em;&#10;                        text-transform: uppercase;&#10;                        letter-spacing: 1px;&#10;                        margin-bottom: 5px;&#10;                    }}&#10;                    .stat-value {{&#10;                        color: #333;&#10;                        font-size: 1.6em;&#10;                        font-weight: bold;&#10;                    }}&#10;                    .total {{&#10;                        border-left-color: #28a745;&#10;                    }}&#10;                    .upload {{&#10;                        border-left-color: #ffc107;&#10;                    }}&#10;                    .download {{&#10;                        border-left-color: #17a2b8;&#10;                    }}&#10;                    .info {{&#10;                        text-align: center;&#10;                        color: #666;&#10;                        margin-top: 20px;&#10;                        font-size: 0.85em;&#10;                    }}&#10;                    .emoji {{&#10;                        font-size: 1.1em;&#10;                        margin-right: 5px;&#10;                    }}&#10;                    .logs-container {{&#10;                        background: #1e1e1e;&#10;                        border-radius: 8px;&#10;                        padding: 15px;&#10;                        max-height: 600px;&#10;                        overflow-y: auto;&#10;                        font-family: 'Consolas', 'Monaco', monospace;&#10;                    }}&#10;                    .log-entry {{&#10;                        color: #d4d4d4;&#10;                        padding: 8px 10px;&#10;                        margin: 5px 0;&#10;                        background: #2d2d2d;&#10;                        border-radius: 4px;&#10;                        font-size: 0.9em;&#10;                        line-height: 1.6;&#10;                        border-left: 3px solid #667eea;&#10;                        display: flex;&#10;                        flex-direction: column;&#10;                        gap: 5px;&#10;                    }}&#10;                    .log-entry:hover {{&#10;                        background: #3d3d3d;&#10;                    }}&#10;                    .log-time {{&#10;                        color: #858585;&#10;                        font-size: 0.85em;&#10;                        font-weight: bold;&#10;                    }}&#10;                    .log-url {{&#10;                        color: #4ec9b0;&#10;                        word-break: break-all;&#10;                    }}&#10;                    .log-stats {{&#10;                        display: flex;&#10;                        gap: 15px;&#10;                        font-size: 0.9em;&#10;                    }}&#10;                    .log-upload {{&#10;                        color: #ffc107;&#10;                    }}&#10;                    .log-download {{&#10;                        color: #17a2b8;&#10;                    }}&#10;                    .log-total {{&#10;                        color: #28a745;&#10;                    }}&#10;                    .logs-container::-webkit-scrollbar {{&#10;                        width: 8px;&#10;                    }}&#10;                    .logs-container::-webkit-scrollbar-track {{&#10;                        background: #1e1e1e;&#10;                    }}&#10;                    .logs-container::-webkit-scrollbar-thumb {{&#10;                        background: #667eea;&#10;                        border-radius: 4px;&#10;                    }}&#10;                    @media (max-width: 968px) {{&#10;                        .wrapper {{&#10;                            grid-template-columns: 1fr;&#10;                        }}&#10;                    }}&#10;                &lt;/style&gt;&#10;            &lt;/head&gt;&#10;            &lt;body&gt;&#10;                &lt;div class=&quot;wrapper&quot;&gt;&#10;                    &lt;div class=&quot;container&quot;&gt;&#10;                        &lt;h1&gt; Proxy Statistics&lt;/h1&gt;&#10;                        &#10;                        &lt;div class=&quot;stat-box total&quot;&gt;&#10;                            &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;✅&lt;/span&gt;Total Data&lt;/div&gt;&#10;                            &lt;div class=&quot;stat-value&quot;&gt;{format_bytes(data['total_data'])}&lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &#10;                        &lt;div class=&quot;stat-box upload&quot;&gt;&#10;                            &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;⬆️&lt;/span&gt;Total Uploaded&lt;/div&gt;&#10;                            &lt;div class=&quot;stat-value&quot;&gt;{format_bytes(data['total_sent'])}&lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &#10;                        &lt;div class=&quot;stat-box download&quot;&gt;&#10;                            &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;⬇️&lt;/span&gt;Total Downloaded&lt;/div&gt;&#10;                            &lt;div class=&quot;stat-value&quot;&gt;{format_bytes(data['total_received'])}&lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &#10;                        &lt;div class=&quot;stat-box&quot;&gt;&#10;                            &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;&lt;/span&gt;Total Requests&lt;/div&gt;&#10;                            &lt;div class=&quot;stat-value&quot;&gt;{data['total_requests']:,}&lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &#10;                        &lt;div class=&quot;stat-box&quot;&gt;&#10;                            &lt;div class=&quot;stat-label&quot;&gt;&lt;span class=&quot;emoji&quot;&gt;⏱️&lt;/span&gt;Uptime&lt;/div&gt;&#10;                            &lt;div class=&quot;stat-value&quot;&gt;{uptime_hours}h {uptime_minutes}m&lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &#10;                        &lt;div class=&quot;info&quot;&gt;&#10;                            Auto-refreshes every 3 seconds&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;div class=&quot;container&quot;&gt;&#10;                        &lt;h2&gt; Live Request Logs&lt;/h2&gt;&#10;                        &lt;div class=&quot;logs-container&quot;&gt;&#10;                            {log_entries if log_entries else '&lt;div class=&quot;log-entry&quot;&gt;No requests yet...&lt;/div&gt;'}&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/body&gt;&#10;            &lt;/html&gt;&#10;            &quot;&quot;&quot;&#10;&#10;            self.send_response(200)&#10;            self.send_header('Content-type', 'text/html; charset=utf-8')&#10;            self.end_headers()&#10;            self.wfile.write(html.encode('utf-8'))&#10;&#10;        elif self.path == '/json':&#10;            data = stats.get_stats()&#10;            self.send_response(200)&#10;            self.send_header('Content-type', 'application/json')&#10;            self.end_headers()&#10;            self.wfile.write(json.dumps(data, indent=2).encode())&#10;        &#10;        elif self.path == '/logs':&#10;            logs = stats.get_logs()&#10;            self.send_response(200)&#10;            self.send_header('Content-type', 'application/json')&#10;            self.end_headers()&#10;            self.wfile.write(json.dumps(logs, indent=2).encode())&#10;&#10;        else:&#10;            self.send_response(404)&#10;            self.end_headers()&#10;&#10;def start_stats_server():&#10;    &quot;&quot;&quot;Start the stats HTTP server&quot;&quot;&quot;&#10;    server = HTTPServer((LOCAL_PROXY_HOST, STATS_SERVER_PORT), StatsHandler)&#10;    print(f&quot;✓ Stats server started on http://{LOCAL_PROXY_HOST}:{STATS_SERVER_PORT}/stats&quot;)&#10;    server.serve_forever()&#10;&#10;class ProxyThread(threading.Thread):&#10;    def __init__(self, client_socket, client_address):&#10;        threading.Thread.__init__(self)&#10;        self.client = client_socket&#10;        self.client_address = client_address&#10;        self.daemon = True&#10;        self.bytes_sent = 0&#10;        self.bytes_received = 0&#10;        self.url = &quot;&quot;&#10;&#10;    def run(self):&#10;        try:&#10;            # Receive the client's request&#10;            request = self.client.recv(4096)&#10;            if not request:&#10;                return&#10;&#10;            request_str = request.decode('latin-1', errors='ignore')&#10;&#10;            # Extract URL from request&#10;            self.url = self.extract_url(request_str)&#10;            self.bytes_sent += len(request)&#10;&#10;            # Add Proxy-Authorization header if not present&#10;            lines = request_str.split('\r\n')&#10;            has_proxy_auth = any('Proxy-Authorization' in line for line in lines)&#10;            &#10;            if not has_proxy_auth:&#10;                # Insert Proxy-Authorization after the first line&#10;                lines.insert(1, f'Proxy-Authorization: Basic {PROXY_AUTH}')&#10;                request_str = '\r\n'.join(lines)&#10;                request = request_str.encode('latin-1')&#10;&#10;            # Connect to the upstream proxy&#10;            upstream = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#10;            upstream.settimeout(10)&#10;            &#10;            try:&#10;                upstream.connect((REMOTE_SERVER, REMOTE_PORT))&#10;                &#10;                # Send the modified request to upstream proxy&#10;                upstream.sendall(request)&#10;                &#10;                # Relay data between client and upstream proxy&#10;                self.relay_data(self.client, upstream)&#10;                &#10;            except socket.timeout:&#10;                self.client.send(b&quot;HTTP/1.1 504 Gateway Timeout\r\n\r\n&quot;)&#10;            except ConnectionRefusedError:&#10;                self.client.send(b&quot;HTTP/1.1 502 Bad Gateway\r\n\r\n&quot;)&#10;            except Exception as e:&#10;                self.client.send(b&quot;HTTP/1.1 502 Bad Gateway\r\n\r\n&quot;)&#10;            finally:&#10;                upstream.close()&#10;                &#10;        except Exception as e:&#10;            pass&#10;        finally:&#10;            self.client.close()&#10;            self.print_stats()&#10;&#10;    def extract_url(self, request_str):&#10;        &quot;&quot;&quot;Extract URL from HTTP request&quot;&quot;&quot;&#10;        try:&#10;            lines = request_str.split('\r\n')&#10;            if lines:&#10;                first_line = lines[0]&#10;                parts = first_line.split(' ')&#10;                if len(parts) &gt;= 2:&#10;                    method = parts[0]&#10;                    url = parts[1]&#10;&#10;                    # If it's a CONNECT request (HTTPS), format it&#10;                    if method == 'CONNECT':&#10;                        return f&quot;https://{url}&quot;&#10;                    # If URL is absolute, use it&#10;                    elif url.startswith('http'):&#10;                        return url&#10;                    # Otherwise, try to find Host header&#10;                    else:&#10;                        for line in lines[1:]:&#10;                            if line.lower().startswith('host:'):&#10;                                host = line.split(':', 1)[1].strip()&#10;                                return f&quot;http://{host}{url}&quot;&#10;                        return url&#10;        except:&#10;            pass&#10;        return &quot;unknown&quot;&#10;&#10;    def format_bytes(self, bytes_count):&#10;        &quot;&quot;&quot;Format bytes to appropriate unit (Bytes, KB, or MB)&quot;&quot;&quot;&#10;        if bytes_count &gt;= 1024 * 1024:  # &gt;= 1MB&#10;            return f&quot;{bytes_count / (1024 * 1024):.1f}MB&quot;&#10;        elif bytes_count &gt;= 1024:  # &gt;= 1KB&#10;            return f&quot;{bytes_count / 1024:.1f}KB&quot;&#10;        else:  # &lt; 1KB&#10;            return f&quot;{bytes_count}B&quot;&#10;&#10;    def print_stats(self):&#10;        &quot;&quot;&quot;Print transfer statistics&quot;&quot;&quot;&#10;        total = self.bytes_sent + self.bytes_received&#10;        if total &gt; 0:&#10;            # Update global stats with URL&#10;            stats.add_request(self.bytes_sent, self.bytes_received, self.url)&#10;            print(f&quot; {self.url} | ⬆️ {self.format_bytes(self.bytes_sent)} | ⬇️ {self.format_bytes(self.bytes_received)} | ✅ {self.format_bytes(total)}&quot;)&#10;&#10;    def relay_data(self, client, upstream):&#10;        &quot;&quot;&quot;Relay data between client and upstream proxy&quot;&quot;&quot;&#10;        try:&#10;            sockets = [client, upstream]&#10;            timeout = 60&#10;            &#10;            while True:&#10;                readable, _, exceptional = select.select(sockets, [], sockets, timeout)&#10;                &#10;                if exceptional:&#10;                    break&#10;                    &#10;                if not readable:&#10;                    break&#10;                &#10;                for sock in readable:&#10;                    try:&#10;                        data = sock.recv(8192)&#10;                        if not data:&#10;                            return&#10;                        &#10;                        if sock is client:&#10;                            upstream.send(data)&#10;                            self.bytes_sent += len(data)&#10;                        else:&#10;                            client.send(data)&#10;                            self.bytes_received += len(data)&#10;                    except:&#10;                        return&#10;                        &#10;        except Exception as e:&#10;            pass&#10;&#10;&#10;def start_proxy_server():&#10;    &quot;&quot;&quot;Start the local proxy server&quot;&quot;&quot;&#10;    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#10;    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)&#10;    &#10;    try:&#10;        server.bind((LOCAL_PROXY_HOST, LOCAL_PROXY_PORT))&#10;        server.listen(100)&#10;        &#10;        print(f&quot;✓ Proxy server started on {LOCAL_PROXY_HOST}:{LOCAL_PROXY_PORT}&quot;)&#10;        print(f&quot;✓ Forwarding to: {REMOTE_SERVER}:{REMOTE_PORT}&quot;)&#10;&#10;        # Start stats server in a separate thread&#10;        stats_thread = threading.Thread(target=start_stats_server, daemon=True)&#10;        stats_thread.start()&#10;&#10;        print(f&quot;✓ Press Ctrl+C to stop\n&quot;)&#10;        &#10;        while True:&#10;            client_socket, client_address = server.accept()&#10;            proxy_thread = ProxyThread(client_socket, client_address)&#10;            proxy_thread.start()&#10;            &#10;    except KeyboardInterrupt:&#10;        print(&quot;\n\nShutting down proxy server...&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Error starting proxy server: {e}&quot;)&#10;    finally:&#10;        server.close()&#10;        print(&quot;Proxy server stopped.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    start_proxy_server()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>