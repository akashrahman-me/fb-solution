<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="import time&#10;import os&#10;import tempfile&#10;import queue&#10;import threading&#10;from datetime import datetime&#10;from io import BytesIO&#10;&#10;from playwright.sync_api import sync_playwright&#10;import logging&#10;from PIL import Image&#10;&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s - %(levelname)s - %(message)s',&#10;    datefmt='%Y-%m-%d %H:%M:%S'&#10;)&#10;logger = logging.getLogger(__name__)&#10;&#10;# Global bandwidth tracking&#10;_total_bandwidth_lock = threading.Lock()&#10;_global_bandwidth_stats = {'total_sent': 0, 'total_received': 0, 'total_requests': 0}&#10;&#10;# Global cache directory&#10;_cache_dir = os.path.join(tempfile.gettempdir(), 'fb_checker_cache')&#10;os.makedirs(_cache_dir, exist_ok=True)&#10;&#10;# Expiration configuration&#10;EXPIRATION_DATE = datetime(2025, 10, 21, 23, 59, 59)&#10;&#10;class ExpirationChecker:&#10;    &quot;&quot;&quot;Handles software expiration logic&quot;&quot;&quot;&#10;    _warning_shown = False&#10;&#10;    @staticmethod&#10;    def check_expiration():&#10;        &quot;&quot;&quot;Check if software has expired. Returns (expired, message)&quot;&quot;&quot;&#10;        if EXPIRATION_DATE is None:&#10;            return False, &quot;No expiration set&quot;&#10;&#10;        now = datetime.now()&#10;        if now &gt; EXPIRATION_DATE:&#10;            days_expired = (now - EXPIRATION_DATE).days&#10;            return True, f&quot;This software expired on {EXPIRATION_DATE.strftime('%B %d, %Y')} ({days_expired} days ago)&quot;&#10;&#10;        days_remaining = (EXPIRATION_DATE - now).days&#10;        hours_remaining = int((EXPIRATION_DATE - now).seconds / 3600)&#10;&#10;        if days_remaining &lt;= 3 and not ExpirationChecker._warning_shown:&#10;            logger.warning(f&quot;Software will expire in {days_remaining} days and {hours_remaining} hours!&quot;)&#10;            ExpirationChecker._warning_shown = True&#10;&#10;        return False, f&quot;Software expires on {EXPIRATION_DATE.strftime('%B %d, %Y at %I:%M %p')}&quot;&#10;&#10;&#10;class FacebookNumberChecker:&#10;    def __init__(self, headless=False, wait_timeout=20):&#10;        expired, message = ExpirationChecker.check_expiration()&#10;        if expired:&#10;            raise Exception(f&quot;SOFTWARE EXPIRED: {message}&quot;)&#10;&#10;        self.headless = headless&#10;        self.wait_timeout = wait_timeout * 1000&#10;        self.playwright = None&#10;        self.browser = None&#10;        self.page = None&#10;        self.context = None&#10;        self.current_phone_number = None&#10;        self.continuation = True&#10;        self.reached_success = False&#10;        self.error_message = None&#10;        self.network_requests = []&#10;        self.cdp_session = None&#10;&#10;        logger.info(&quot;Session initialized&quot;)&#10;&#10;    def setup_driver(self):&#10;        expired, message = ExpirationChecker.check_expiration()&#10;        if expired:&#10;            raise Exception(f&quot;SOFTWARE EXPIRED: {message}&quot;)&#10;&#10;        self.playwright = sync_playwright().start()&#10;        self.browser = self.playwright.chromium.launch(&#10;            headless=self.headless,&#10;            args=[&#10;                '--disable-blink-features=AutomationControlled',&#10;                '--disable-dev-shm-usage',&#10;                '--no-sandbox',&#10;                '--disable-gpu',&#10;                '--log-level=3',&#10;                '--silent',&#10;            ]&#10;        )&#10;        #&#10;        proxy_config = {&#10;            &quot;server&quot;: &quot;http://127.0.0.1:8080&quot;&#10;        }&#10;&#10;        # Create a context with proxy enabled for proper caching and proxy support&#10;        self.context = self.browser.new_context(&#10;            proxy = proxy_config&#10;        )&#10;        self.page = self.context.new_page()&#10;&#10;        # Use CDP to accurately track network bandwidth&#10;        self.cdp_session = self.context.new_cdp_session(self.page)&#10;        self.cdp_session.send('Network.enable')&#10;&#10;        # Listen to CDP Network events for accurate tracking&#10;        self.cdp_session.on('Network.responseReceived', self._on_cdp_response)&#10;        self.cdp_session.on('Network.loadingFinished', self._on_cdp_loading_finished)&#10;&#10;        # Store request IDs and their info&#10;        self.pending_requests = {}&#10;&#10;        self.page.set_default_timeout(self.wait_timeout)&#10;&#10;        logger.info(f&quot;Browser initialized (headless={self.headless}) with proxy&quot;)&#10;&#10;    def _on_cdp_response(self, params):&#10;        &quot;&quot;&quot;Handle CDP Network.responseReceived event&quot;&quot;&quot;&#10;        try:&#10;            request_id = params.get('requestId')&#10;            response = params.get('response', {})&#10;&#10;            # Check if response was served from cache&#10;            from_disk_cache = response.get('fromDiskCache', False)&#10;            from_service_worker = response.get('fromServiceWorker', False)&#10;            from_prefetch_cache = response.get('fromPrefetchCache', False)&#10;&#10;            # Skip cached resources&#10;            if from_disk_cache or from_service_worker or from_prefetch_cache:&#10;                return&#10;&#10;            # Store info for this request&#10;            self.pending_requests[request_id] = {&#10;                'url': response.get('url', ''),&#10;                'status': response.get('status', 0),&#10;                'headers': response.get('headers', {}),&#10;                'encoded_data_length': 0&#10;            }&#10;        except:&#10;            pass&#10;&#10;    def _on_cdp_loading_finished(self, params):&#10;        &quot;&quot;&quot;Handle CDP Network.loadingFinished event&quot;&quot;&quot;&#10;        try:&#10;            request_id = params.get('requestId')&#10;            encoded_data_length = params.get('encodedDataLength', 0)&#10;&#10;            if request_id in self.pending_requests:&#10;                request_info = self.pending_requests[request_id]&#10;&#10;                # Skip data URLs&#10;                url = request_info['url']&#10;                if url.startswith('data:') or url.startswith('blob:'):&#10;                    del self.pending_requests[request_id]&#10;                    return&#10;&#10;                # Calculate actual bandwidth&#10;                # encodedDataLength includes headers + body as received over network&#10;                if encoded_data_length &gt; 0:&#10;                    self.network_requests.append({&#10;                        'bytes_sent': 0,  # Request size is minimal (headers only)&#10;                        'bytes_received': encoded_data_length,&#10;                        'url': url,&#10;                        'status': request_info['status']&#10;                    })&#10;&#10;                # Clean up&#10;                del self.pending_requests[request_id]&#10;        except:&#10;            pass&#10;&#10;    def get_network_stats(self):&#10;        &quot;&quot;&quot;Retrieve network statistics&quot;&quot;&quot;&#10;        return {&#10;            'bytes_sent': sum(req['bytes_sent'] for req in self.network_requests),&#10;            'bytes_received': sum(req['bytes_received'] for req in self.network_requests),&#10;            'requests_count': len(self.network_requests)&#10;        }&#10;&#10;    @staticmethod&#10;    def format_bytes(bytes_value):&#10;        &quot;&quot;&quot;Convert bytes to human-readable format&quot;&quot;&quot;&#10;        for unit in ['B', 'KB', 'MB', 'GB']:&#10;            if bytes_value &lt; 1024.0:&#10;                return f&quot;{bytes_value:.2f} {unit}&quot;&#10;            bytes_value /= 1024.0&#10;        return f&quot;{bytes_value:.2f} TB&quot;&#10;&#10;    def _click_element(self, selector, description, use_alt=False):&#10;        &quot;&quot;&quot;Helper to click element with fallback&quot;&quot;&quot;&#10;        try:&#10;            element = self.page.locator(selector).first&#10;            element.wait_for(state=&quot;visible&quot;, timeout=self.wait_timeout)&#10;            element.click()&#10;            logger.info(f&quot;Clicked {description}&quot;)&#10;        except Exception as e:&#10;            if use_alt:&#10;                raise&#10;            logger.error(f&quot;Error clicking {description}: {e}&quot;)&#10;&#10;    def _stop_with_error(self, error_msg):&#10;        &quot;&quot;&quot;Helper to stop continuation with error message&quot;&quot;&quot;&#10;        self.continuation = False&#10;        self.error_message = error_msg&#10;        logger.info(error_msg)&#10;&#10;    def wait_for_text_and_execute(self, text_actions_map):&#10;        &quot;&quot;&quot;Wait for text to appear and execute corresponding action&quot;&quot;&quot;&#10;        poll_frequency = 0.3&#10;        max_time = self.wait_timeout / 1000&#10;        start_time = time.time()&#10;&#10;        while time.time() - start_time &lt; max_time:&#10;            try:&#10;                page_source = self.page.content()&#10;                for text, action in text_actions_map.items():&#10;                    if text in page_source:&#10;                        element = self.page.locator(f&quot;//*[contains(text(), '{text}')]&quot;).first&#10;                        if element.count() &gt; 0:&#10;                            logger.info(f&quot;Found text: '{text}'&quot;)&#10;                            action()&#10;                            return text&#10;                time.sleep(poll_frequency)&#10;            except:&#10;                time.sleep(poll_frequency)&#10;        return None&#10;&#10;    def search_phone_number(self, phone_number):&#10;        self.current_phone_number = phone_number&#10;        self.page.goto(&quot;https://www.facebook.com/login/identify/&quot;)&#10;&#10;    def select_account(self):&#10;        self._click_element(&quot;//a[contains(text(), 'This is my account')]&quot;, &quot;first account&quot;)&#10;&#10;    def continue_send_code(self):&#10;        phone_to_match = ''.join(filter(str.isdigit, self.current_phone_number))&#10;        all_radios = self.page.locator(&quot;//input[@type='radio' and @name='recover_method']&quot;).all()&#10;&#10;        sms_radio = None&#10;        for radio in all_radios:&#10;            try:&#10;                radio_id = radio.get_attribute('id')&#10;                if not radio_id or not radio_id.startswith('send_sms:'):&#10;                    continue&#10;&#10;                label = self.page.locator(f&quot;//label[@for='{radio_id}']&quot;).first&#10;                label_text = label.text_content()&#10;&#10;                if &quot;Send code via SMS&quot; not in label_text:&#10;                    continue&#10;&#10;                phone_in_label = ''.join(filter(str.isdigit, label_text))&#10;                if (phone_to_match == phone_in_label or phone_to_match in phone_in_label or&#10;                    phone_in_label in phone_to_match):&#10;                    if '*' not in label_text or phone_to_match in label_text.replace('+', ''):&#10;                        sms_radio = radio&#10;                        break&#10;            except Exception as e:&#10;                logger.debug(f&quot;Error processing radio button: {e}&quot;)&#10;&#10;        if not sms_radio:&#10;            self._stop_with_error(&quot;Can't find the 'Send code via SMS' option.&quot;)&#10;            return&#10;&#10;        if not sms_radio.is_checked():&#10;            sms_radio.click()&#10;            logger.info(&quot;SMS radio button clicked&quot;)&#10;&#10;        self._click_element(&quot;//button[@name='reset_action' and @type='submit' and contains(text(), 'Continue')]&quot;,&#10;                           &quot;Continue button&quot;)&#10;&#10;    def on_disabled(self):&#10;        self._stop_with_error(&quot;Account is disabled&quot;)&#10;&#10;    def on_verification_send(self):&#10;        self.continuation = False&#10;        self.reached_success = True&#10;        logger.info(&quot;Verification code input page reached&quot;)&#10;&#10;    def no_search_results(self):&#10;        self._stop_with_error(&quot;Facebook account isn't found&quot;)&#10;&#10;    def on_robot_detected(self):&#10;        self._stop_with_error(&quot;Robot detected - CAPTCHA required&quot;)&#10;&#10;    def temporary_blocked(self):&#10;        self._stop_with_error(&quot;You're Temporarily Blocked&quot;)&#10;&#10;    def try_another_way(self):&#10;        try:&#10;            self._click_element(&quot;//a[@name='tryanotherway' and contains(text(), 'Try another way')]&quot;,&#10;                               &quot;Try another way&quot;)&#10;        except:&#10;            try:&#10;                self._click_element(&quot;[name='tryanotherway']&quot;, &quot;Try another way (alt)&quot;, use_alt=True)&#10;            except Exception as e:&#10;                logger.error(f&quot;Failed to click 'Try another way': {e}&quot;)&#10;                raise&#10;&#10;    def reload_page(self):&#10;        self.page.reload()&#10;&#10;    def direct_code_send(self):&#10;        &quot;&quot;&quot;Handle direct code send option&quot;&quot;&quot;&#10;        try:&#10;            self._click_element(&quot;//button[@type='submit' and contains(text(), 'Continue')]&quot;, &quot;Continue&quot;)&#10;        except:&#10;            try:&#10;                self._click_element(&quot;//button[@type='submit']&quot;, &quot;Continue (alt)&quot;, use_alt=True)&#10;            except Exception as e:&#10;                logger.error(f&quot;Failed to click Continue: {e}&quot;)&#10;                raise&#10;&#10;    def click_clickable_parent(self, element):&#10;        &quot;&quot;&quot;Recursively find and click clickable parent&quot;&quot;&quot;&#10;        try:&#10;            if element.is_visible() and element.is_enabled():&#10;                element.click()&#10;                return True&#10;            parent = element.locator(&quot;xpath=..&quot;).first&#10;            if parent.evaluate(&quot;el =&gt; el.tagName&quot;).lower() == &quot;html&quot;:&#10;                return False&#10;            return self.click_clickable_parent(parent)&#10;        except:&#10;            return False&#10;&#10;    def allow_cookie(self):&#10;        try:&#10;            cookie_element = self.page.locator(&quot;//*[contains(text(), 'Allow all cookies')]&quot;).first&#10;            if cookie_element.count() &gt; 0:&#10;                self.click_clickable_parent(cookie_element)&#10;        except:&#10;            logger.debug(&quot;No cookie popup found&quot;)&#10;&#10;    def find_account(self):&#10;        email_input = self.page.locator(&quot;#identify_email&quot;).first&#10;        email_input.wait_for(state=&quot;visible&quot;, timeout=self.wait_timeout)&#10;        email_input.clear()&#10;        email_input.type(self.current_phone_number)&#10;        self._click_element(&quot;#did_submit&quot;, &quot;search button&quot;)&#10;        logger.info(f&quot;Searched for phone number: {self.current_phone_number}&quot;)&#10;&#10;    def try_another_device(self):&#10;        self._stop_with_error(&quot;Try another device to continue&quot;)&#10;&#10;    def _save_debug_info(self):&#10;        &quot;&quot;&quot;Save screenshot and HTML for debugging&quot;&quot;&quot;&#10;        if self.current_phone_number:&#10;            self.page.screenshot(path=f&quot;photo/{self.current_phone_number}.png&quot;)&#10;            os.makedirs(&quot;html&quot;, exist_ok=True)&#10;            with open(f&quot;html/{self.current_phone_number}.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:&#10;                f.write(self.page.content())&#10;&#10;    def handle_continuation(self):&#10;        &quot;&quot;&quot;Main flow handler&quot;&quot;&quot;&#10;        text_actions = {&#10;            &quot;Allow the use of cookies from Facebook on this browser?&quot;: self.allow_cookie,&#10;            &quot;Find Your Account&quot;: self.find_account,&#10;            &quot;These accounts matched your search&quot;: self.select_account,&#10;            &quot;How do you want to receive the code to reset your password?&quot;: self.continue_send_code,&#10;            &quot;How do you want to get the code to reset your password?&quot;: self.continue_send_code,&#10;            &quot;Before we send the code, enter these letters and numbers&quot;: self.on_robot_detected,&#10;            &quot;Enter security code&quot;: self.on_verification_send,&#10;            &quot;Account disabled&quot;: self.on_disabled,&#10;            &quot;No search results&quot;: self.no_search_results,&#10;            &quot;Log in as&quot;: self.try_another_way,&#10;            &quot;Log in to&quot;: self.try_another_way,&#10;            &quot;Reload page&quot;: self.reload_page,&#10;            &quot;We can send a login code to:&quot;: self.direct_code_send,&#10;            &quot;You're Temporarily Blocked&quot;: self.temporary_blocked,&#10;            &quot;Try another device to continue&quot;: self.try_another_device,&#10;        }&#10;&#10;        try:&#10;            while self.continuation:&#10;                found_text = self.wait_for_text_and_execute(text_actions)&#10;&#10;                if not found_text:&#10;                    logger.warning(&quot;No expected text found&quot;)&#10;                    self._save_debug_info()&#10;                    break&#10;&#10;                if found_text in text_actions:&#10;                    del text_actions[found_text]&#10;&#10;                if not text_actions:&#10;                    break&#10;        except Exception as e:&#10;            logger.error(f&quot;An error occurred: {e}&quot;)&#10;            raise&#10;&#10;    def page_preview(self):&#10;        &quot;&quot;&quot;Show screenshot preview&quot;&quot;&quot;&#10;        screenshot_bytes = self.page.screenshot()&#10;        Image.open(BytesIO(screenshot_bytes)).show()&#10;        logger.info(&quot;Screenshot preview opened&quot;)&#10;&#10;    def _log_bandwidth(self, stats):&#10;        &quot;&quot;&quot;Log bandwidth usage&quot;&quot;&quot;&#10;        total = stats['bytes_sent'] + stats['bytes_received']&#10;        logger.info(f&quot;Bandwidth: Sent={self.format_bytes(stats['bytes_sent'])}, &quot;&#10;                   f&quot;Received={self.format_bytes(stats['bytes_received'])}, &quot;&#10;                   f&quot;Total={self.format_bytes(total)}, Requests={stats['requests_count']}&quot;)&#10;&#10;    def _update_global_bandwidth(self, stats):&#10;        &quot;&quot;&quot;Update global bandwidth statistics&quot;&quot;&quot;&#10;        with _total_bandwidth_lock:&#10;            _global_bandwidth_stats['total_sent'] += stats['bytes_sent']&#10;            _global_bandwidth_stats['total_received'] += stats['bytes_received']&#10;            _global_bandwidth_stats['total_requests'] += stats['requests_count']&#10;&#10;    def close(self):&#10;        &quot;&quot;&quot;Clean up resources&quot;&quot;&quot;&#10;        if self.page:&#10;            stats = self.get_network_stats()&#10;            self._log_bandwidth(stats)&#10;            self._update_global_bandwidth(stats)&#10;&#10;            input(&quot;Enter to close&quot;)&#10;&#10;            self.page.close()&#10;            if self.browser:&#10;                self.browser.close()&#10;            if self.playwright:&#10;                self.playwright.stop()&#10;            logger.info(&quot;Browser closed&quot;)&#10;&#10;    def check_number(self, phone_number):&#10;        &quot;&quot;&quot;Check a single phone number&quot;&quot;&quot;&#10;        self.current_phone_number = phone_number&#10;        try:&#10;            self.search_phone_number(phone_number)&#10;            self.handle_continuation()&#10;&#10;            if self.reached_success:&#10;                return {'phone': phone_number, 'status': 'success', 'message': 'Verification code page reached'}&#10;            elif self.error_message:&#10;                return {'phone': phone_number, 'status': 'failed', 'message': self.error_message}&#10;            else:&#10;                return {'phone': phone_number, 'status': 'failed', 'message': 'Unknown error - didn\'t reach verification page'}&#10;        except Exception as e:&#10;            logger.error(f&quot;Error checking {phone_number}: {e}&quot;)&#10;            return {'phone': phone_number, 'status': 'error', 'message': str(e)}&#10;&#10;&#10;def check_single_number(phone_number):&#10;    &quot;&quot;&quot;Worker function to check a single phone number&quot;&quot;&quot;&#10;    checker = FacebookNumberChecker(headless=False)&#10;    try:&#10;        checker.setup_driver()&#10;        result = checker.check_number(phone_number)&#10;        logger.info(f&quot;Completed check for {phone_number}: {result['status']}&quot;)&#10;        return result&#10;    except Exception as e:&#10;        logger.error(f&quot;Worker error for {phone_number}: {e}&quot;)&#10;        return {'phone': phone_number, 'status': 'error', 'message': str(e)}&#10;    finally:&#10;        checker.close()&#10;&#10;&#10;def string_to_number_array(data_str):&#10;    &quot;&quot;&quot;Convert multi-line string of numbers to list&quot;&quot;&quot;&#10;    return [num.strip() for num in data_str.split('\n') if num.strip()]&#10;&#10;&#10;def worker_process_numbers(worker_id, phone_queue, results_list, results_lock):&#10;    &quot;&quot;&quot;Worker that processes multiple phone numbers with one browser instance&quot;&quot;&quot;&#10;    checker = FacebookNumberChecker(headless=False)&#10;    phones_processed = 0&#10;&#10;    try:&#10;        checker.setup_driver()&#10;        logger.info(f&quot;Worker {worker_id} browser ready&quot;)&#10;&#10;        while True:&#10;            try:&#10;                phone_number = phone_queue.get(timeout=1)&#10;&#10;                # Reset state&#10;                checker.continuation = True&#10;                checker.reached_success = False&#10;                checker.error_message = None&#10;                checker.network_requests = []&#10;&#10;                logger.info(f&quot;Worker {worker_id} checking: {phone_number}&quot;)&#10;                result = checker.check_number(phone_number)&#10;                phones_processed += 1&#10;&#10;                # Log and update bandwidth&#10;                stats = checker.get_network_stats()&#10;                checker._log_bandwidth(stats)&#10;                checker._update_global_bandwidth(stats)&#10;&#10;                # Store result&#10;                with results_lock:&#10;                    results_list.append(result)&#10;                    logger.info(f&quot;Progress: {len(results_list)}/{phone_queue.qsize() + len(results_list)} completed&quot;)&#10;&#10;                phone_queue.task_done()&#10;&#10;            except queue.Empty:&#10;                logger.info(f&quot;Worker {worker_id} finished - processed {phones_processed} numbers&quot;)&#10;                break&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Worker {worker_id} error: {e}&quot;)&#10;    finally:&#10;        input(&quot;Enter to finally close&quot;)&#10;        if checker.page:&#10;            checker.page.close()&#10;        if checker.browser:&#10;            checker.browser.close()&#10;        if checker.playwright:&#10;            checker.playwright.stop()&#10;        logger.info(f&quot;Worker {worker_id} browser closed&quot;)&#10;&#10;&#10;def print_summary(results):&#10;    &quot;&quot;&quot;Print final summary of results&quot;&quot;&quot;&#10;    logger.info(&quot;=&quot; * 50)&#10;    logger.info(&quot;FINAL RESULTS:&quot;)&#10;    logger.info(&quot;=&quot; * 50)&#10;&#10;    success_count = sum(1 for r in results if r['status'] == 'success')&#10;    error_count = sum(1 for r in results if r['status'] == 'error')&#10;&#10;    logger.info(f&quot;Total checked: {len(results)}&quot;)&#10;    logger.info(f&quot;Successful: {success_count}&quot;)&#10;    logger.info(f&quot;Errors: {error_count}&quot;)&#10;&#10;    logger.info(&quot;\nDetailed results:&quot;)&#10;    for result in results:&#10;        logger.info(f&quot;{result['phone']}: {result['status']} - {result['message']}&quot;)&#10;&#10;&#10;def print_bandwidth_summary(num_results):&#10;    &quot;&quot;&quot;Print total bandwidth usage&quot;&quot;&quot;&#10;    logger.info(&quot;=&quot; * 50)&#10;    logger.info(&quot;TOTAL BANDWIDTH USAGE:&quot;)&#10;    logger.info(&quot;=&quot; * 50)&#10;&#10;    total_sent = _global_bandwidth_stats['total_sent']&#10;    total_received = _global_bandwidth_stats['total_received']&#10;    total_bandwidth = total_sent + total_received&#10;&#10;    logger.info(f&quot;Total Sent: {FacebookNumberChecker.format_bytes(total_sent)}&quot;)&#10;    logger.info(f&quot;Total Received: {FacebookNumberChecker.format_bytes(total_received)}&quot;)&#10;    logger.info(f&quot;Total Bandwidth: {FacebookNumberChecker.format_bytes(total_bandwidth)}&quot;)&#10;    logger.info(f&quot;Total Requests: {_global_bandwidth_stats['total_requests']}&quot;)&#10;&#10;    if num_results &gt; 0:&#10;        avg = total_bandwidth / num_results&#10;        logger.info(f&quot;Average Bandwidth per Check: {FacebookNumberChecker.format_bytes(avg)}&quot;)&#10;&#10;    logger.info(&quot;=&quot; * 50)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    nums_str = &quot;&quot;&quot;&#10;2250779359702&#10;2250779356403&#10;2250779354097&#10;2250779355845&#10;2250779354549&#10;2250779352567&#10;2250779350481&#10;2250779357023&#10;2250779354188&#10;2250779355447&#10;    &quot;&quot;&quot;&#10;&#10;    nums = string_to_number_array(nums_str)&#10;    phone_queue = queue.Queue()&#10;    for num in nums:&#10;        phone_queue.put(num)&#10;&#10;    results = []&#10;    results_lock = threading.Lock()&#10;    num_workers = 1&#10;&#10;    logger.info(f&quot;Starting to check {len(nums)} phone numbers with {num_workers} concurrent workers&quot;)&#10;&#10;    # Create and start workers&#10;    workers = [&#10;        threading.Thread(target=worker_process_numbers, args=(i, phone_queue, results, results_lock))&#10;        for i in range(num_workers)&#10;    ]&#10;&#10;    for worker in workers:&#10;        worker.start()&#10;&#10;    for worker in workers:&#10;        worker.join()&#10;&#10;    print_summary(results)&#10;    print_bandwidth_summary(len(results))&#10;" />
              <option name="updatedContent" value="import time&#10;import os&#10;import tempfile&#10;import queue&#10;import threading&#10;from datetime import datetime&#10;from io import BytesIO&#10;&#10;from playwright.sync_api import sync_playwright&#10;import logging&#10;from PIL import Image&#10;&#10;logging.basicConfig(&#10;    level=logging.INFO,&#10;    format='%(asctime)s - %(levelname)s - %(message)s',&#10;    datefmt='%Y-%m-%d %H:%M:%S'&#10;)&#10;logger = logging.getLogger(__name__)&#10;&#10;# Global cache directory&#10;_cache_dir = os.path.join(tempfile.gettempdir(), 'fb_checker_cache')&#10;os.makedirs(_cache_dir, exist_ok=True)&#10;&#10;# Expiration configuration&#10;EXPIRATION_DATE = datetime(2025, 10, 21, 23, 59, 59)&#10;&#10;class ExpirationChecker:&#10;    &quot;&quot;&quot;Handles software expiration logic&quot;&quot;&quot;&#10;    _warning_shown = False&#10;&#10;    @staticmethod&#10;    def check_expiration():&#10;        &quot;&quot;&quot;Check if software has expired. Returns (expired, message)&quot;&quot;&quot;&#10;        if EXPIRATION_DATE is None:&#10;            return False, &quot;No expiration set&quot;&#10;&#10;        now = datetime.now()&#10;        if now &gt; EXPIRATION_DATE:&#10;            days_expired = (now - EXPIRATION_DATE).days&#10;            return True, f&quot;This software expired on {EXPIRATION_DATE.strftime('%B %d, %Y')} ({days_expired} days ago)&quot;&#10;&#10;        days_remaining = (EXPIRATION_DATE - now).days&#10;        hours_remaining = int((EXPIRATION_DATE - now).seconds / 3600)&#10;&#10;        if days_remaining &lt;= 3 and not ExpirationChecker._warning_shown:&#10;            logger.warning(f&quot;Software will expire in {days_remaining} days and {hours_remaining} hours!&quot;)&#10;            ExpirationChecker._warning_shown = True&#10;&#10;        return False, f&quot;Software expires on {EXPIRATION_DATE.strftime('%B %d, %Y at %I:%M %p')}&quot;&#10;&#10;&#10;class FacebookNumberChecker:&#10;    def __init__(self, headless=False, wait_timeout=20):&#10;        expired, message = ExpirationChecker.check_expiration()&#10;        if expired:&#10;            raise Exception(f&quot;SOFTWARE EXPIRED: {message}&quot;)&#10;&#10;        self.headless = headless&#10;        self.wait_timeout = wait_timeout * 1000&#10;        self.playwright = None&#10;        self.browser = None&#10;        self.page = None&#10;        self.context = None&#10;        self.current_phone_number = None&#10;        self.continuation = True&#10;        self.reached_success = False&#10;        self.error_message = None&#10;&#10;        logger.info(&quot;Session initialized&quot;)&#10;&#10;    def setup_driver(self):&#10;        expired, message = ExpirationChecker.check_expiration()&#10;        if expired:&#10;            raise Exception(f&quot;SOFTWARE EXPIRED: {message}&quot;)&#10;&#10;        self.playwright = sync_playwright().start()&#10;        self.browser = self.playwright.chromium.launch(&#10;            headless=self.headless,&#10;            args=[&#10;                '--disable-blink-features=AutomationControlled',&#10;                '--disable-dev-shm-usage',&#10;                '--no-sandbox',&#10;                '--disable-gpu',&#10;                '--log-level=3',&#10;                '--silent',&#10;            ]&#10;        )&#10;        #&#10;        proxy_config = {&#10;            &quot;server&quot;: &quot;http://127.0.0.1:8080&quot;&#10;        }&#10;&#10;        # Create a context with proxy enabled for proper caching and proxy support&#10;        self.context = self.browser.new_context(&#10;            proxy = proxy_config&#10;        )&#10;        self.page = self.context.new_page()&#10;&#10;        self.page.set_default_timeout(self.wait_timeout)&#10;&#10;        logger.info(f&quot;Browser initialized (headless={self.headless}) with proxy&quot;)&#10;&#10;    def _click_element(self, selector, description, use_alt=False):&#10;        &quot;&quot;&quot;Helper to click element with fallback&quot;&quot;&quot;&#10;        try:&#10;            element = self.page.locator(selector).first&#10;            element.wait_for(state=&quot;visible&quot;, timeout=self.wait_timeout)&#10;            element.click()&#10;            logger.info(f&quot;Clicked {description}&quot;)&#10;        except Exception as e:&#10;            if use_alt:&#10;                raise&#10;            logger.error(f&quot;Error clicking {description}: {e}&quot;)&#10;&#10;    def _stop_with_error(self, error_msg):&#10;        &quot;&quot;&quot;Helper to stop continuation with error message&quot;&quot;&quot;&#10;        self.continuation = False&#10;        self.error_message = error_msg&#10;        logger.info(error_msg)&#10;&#10;    def wait_for_text_and_execute(self, text_actions_map):&#10;        &quot;&quot;&quot;Wait for text to appear and execute corresponding action&quot;&quot;&quot;&#10;        poll_frequency = 0.3&#10;        max_time = self.wait_timeout / 1000&#10;        start_time = time.time()&#10;&#10;        while time.time() - start_time &lt; max_time:&#10;            try:&#10;                page_source = self.page.content()&#10;                for text, action in text_actions_map.items():&#10;                    if text in page_source:&#10;                        element = self.page.locator(f&quot;//*[contains(text(), '{text}')]&quot;).first&#10;                        if element.count() &gt; 0:&#10;                            logger.info(f&quot;Found text: '{text}'&quot;)&#10;                            action()&#10;                            return text&#10;                time.sleep(poll_frequency)&#10;            except:&#10;                time.sleep(poll_frequency)&#10;        return None&#10;&#10;    def search_phone_number(self, phone_number):&#10;        self.current_phone_number = phone_number&#10;        self.page.goto(&quot;https://www.facebook.com/login/identify/&quot;)&#10;&#10;    def select_account(self):&#10;        self._click_element(&quot;//a[contains(text(), 'This is my account')]&quot;, &quot;first account&quot;)&#10;&#10;    def continue_send_code(self):&#10;        phone_to_match = ''.join(filter(str.isdigit, self.current_phone_number))&#10;        all_radios = self.page.locator(&quot;//input[@type='radio' and @name='recover_method']&quot;).all()&#10;&#10;        sms_radio = None&#10;        for radio in all_radios:&#10;            try:&#10;                radio_id = radio.get_attribute('id')&#10;                if not radio_id or not radio_id.startswith('send_sms:'):&#10;                    continue&#10;&#10;                label = self.page.locator(f&quot;//label[@for='{radio_id}']&quot;).first&#10;                label_text = label.text_content()&#10;&#10;                if &quot;Send code via SMS&quot; not in label_text:&#10;                    continue&#10;&#10;                phone_in_label = ''.join(filter(str.isdigit, label_text))&#10;                if (phone_to_match == phone_in_label or phone_to_match in phone_in_label or&#10;                    phone_in_label in phone_to_match):&#10;                    if '*' not in label_text or phone_to_match in label_text.replace('+', ''):&#10;                        sms_radio = radio&#10;                        break&#10;            except Exception as e:&#10;                logger.debug(f&quot;Error processing radio button: {e}&quot;)&#10;&#10;        if not sms_radio:&#10;            self._stop_with_error(&quot;Can't find the 'Send code via SMS' option.&quot;)&#10;            return&#10;&#10;        if not sms_radio.is_checked():&#10;            sms_radio.click()&#10;            logger.info(&quot;SMS radio button clicked&quot;)&#10;&#10;        self._click_element(&quot;//button[@name='reset_action' and @type='submit' and contains(text(), 'Continue')]&quot;,&#10;                           &quot;Continue button&quot;)&#10;&#10;    def on_disabled(self):&#10;        self._stop_with_error(&quot;Account is disabled&quot;)&#10;&#10;    def on_verification_send(self):&#10;        self.continuation = False&#10;        self.reached_success = True&#10;        logger.info(&quot;Verification code input page reached&quot;)&#10;&#10;    def no_search_results(self):&#10;        self._stop_with_error(&quot;Facebook account isn't found&quot;)&#10;&#10;    def on_robot_detected(self):&#10;        self._stop_with_error(&quot;Robot detected - CAPTCHA required&quot;)&#10;&#10;    def temporary_blocked(self):&#10;        self._stop_with_error(&quot;You're Temporarily Blocked&quot;)&#10;&#10;    def try_another_way(self):&#10;        try:&#10;            self._click_element(&quot;//a[@name='tryanotherway' and contains(text(), 'Try another way')]&quot;,&#10;                               &quot;Try another way&quot;)&#10;        except:&#10;            try:&#10;                self._click_element(&quot;[name='tryanotherway']&quot;, &quot;Try another way (alt)&quot;, use_alt=True)&#10;            except Exception as e:&#10;                logger.error(f&quot;Failed to click 'Try another way': {e}&quot;)&#10;                raise&#10;&#10;    def reload_page(self):&#10;        self.page.reload()&#10;&#10;    def direct_code_send(self):&#10;        &quot;&quot;&quot;Handle direct code send option&quot;&quot;&quot;&#10;        try:&#10;            self._click_element(&quot;//button[@type='submit' and contains(text(), 'Continue')]&quot;, &quot;Continue&quot;)&#10;        except:&#10;            try:&#10;                self._click_element(&quot;//button[@type='submit']&quot;, &quot;Continue (alt)&quot;, use_alt=True)&#10;            except Exception as e:&#10;                logger.error(f&quot;Failed to click Continue: {e}&quot;)&#10;                raise&#10;&#10;    def click_clickable_parent(self, element):&#10;        &quot;&quot;&quot;Recursively find and click clickable parent&quot;&quot;&quot;&#10;        try:&#10;            if element.is_visible() and element.is_enabled():&#10;                element.click()&#10;                return True&#10;            parent = element.locator(&quot;xpath=..&quot;).first&#10;            if parent.evaluate(&quot;el =&gt; el.tagName&quot;).lower() == &quot;html&quot;:&#10;                return False&#10;            return self.click_clickable_parent(parent)&#10;        except:&#10;            return False&#10;&#10;    def allow_cookie(self):&#10;        try:&#10;            cookie_element = self.page.locator(&quot;//*[contains(text(), 'Allow all cookies')]&quot;).first&#10;            if cookie_element.count() &gt; 0:&#10;                self.click_clickable_parent(cookie_element)&#10;        except:&#10;            logger.debug(&quot;No cookie popup found&quot;)&#10;&#10;    def find_account(self):&#10;        email_input = self.page.locator(&quot;#identify_email&quot;).first&#10;        email_input.wait_for(state=&quot;visible&quot;, timeout=self.wait_timeout)&#10;        email_input.clear()&#10;        email_input.type(self.current_phone_number)&#10;        self._click_element(&quot;#did_submit&quot;, &quot;search button&quot;)&#10;        logger.info(f&quot;Searched for phone number: {self.current_phone_number}&quot;)&#10;&#10;    def try_another_device(self):&#10;        self._stop_with_error(&quot;Try another device to continue&quot;)&#10;&#10;    def _save_debug_info(self):&#10;        &quot;&quot;&quot;Save screenshot and HTML for debugging&quot;&quot;&quot;&#10;        if self.current_phone_number:&#10;            self.page.screenshot(path=f&quot;photo/{self.current_phone_number}.png&quot;)&#10;            os.makedirs(&quot;html&quot;, exist_ok=True)&#10;            with open(f&quot;html/{self.current_phone_number}.html&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:&#10;                f.write(self.page.content())&#10;&#10;    def handle_continuation(self):&#10;        &quot;&quot;&quot;Main flow handler&quot;&quot;&quot;&#10;        text_actions = {&#10;            &quot;Allow the use of cookies from Facebook on this browser?&quot;: self.allow_cookie,&#10;            &quot;Find Your Account&quot;: self.find_account,&#10;            &quot;These accounts matched your search&quot;: self.select_account,&#10;            &quot;How do you want to receive the code to reset your password?&quot;: self.continue_send_code,&#10;            &quot;How do you want to get the code to reset your password?&quot;: self.continue_send_code,&#10;            &quot;Before we send the code, enter these letters and numbers&quot;: self.on_robot_detected,&#10;            &quot;Enter security code&quot;: self.on_verification_send,&#10;            &quot;Account disabled&quot;: self.on_disabled,&#10;            &quot;No search results&quot;: self.no_search_results,&#10;            &quot;Log in as&quot;: self.try_another_way,&#10;            &quot;Log in to&quot;: self.try_another_way,&#10;            &quot;Reload page&quot;: self.reload_page,&#10;            &quot;We can send a login code to:&quot;: self.direct_code_send,&#10;            &quot;You're Temporarily Blocked&quot;: self.temporary_blocked,&#10;            &quot;Try another device to continue&quot;: self.try_another_device,&#10;        }&#10;&#10;        try:&#10;            while self.continuation:&#10;                found_text = self.wait_for_text_and_execute(text_actions)&#10;&#10;                if not found_text:&#10;                    logger.warning(&quot;No expected text found&quot;)&#10;                    self._save_debug_info()&#10;                    break&#10;&#10;                if found_text in text_actions:&#10;                    del text_actions[found_text]&#10;&#10;                if not text_actions:&#10;                    break&#10;        except Exception as e:&#10;            logger.error(f&quot;An error occurred: {e}&quot;)&#10;            raise&#10;&#10;    def page_preview(self):&#10;        &quot;&quot;&quot;Show screenshot preview&quot;&quot;&quot;&#10;        screenshot_bytes = self.page.screenshot()&#10;        Image.open(BytesIO(screenshot_bytes)).show()&#10;        logger.info(&quot;Screenshot preview opened&quot;)&#10;&#10;    def close(self):&#10;        &quot;&quot;&quot;Clean up resources&quot;&quot;&quot;&#10;        if self.page:&#10;            input(&quot;Enter to close&quot;)&#10;&#10;            self.page.close()&#10;            if self.browser:&#10;                self.browser.close()&#10;            if self.playwright:&#10;                self.playwright.stop()&#10;            logger.info(&quot;Browser closed&quot;)&#10;&#10;    def check_number(self, phone_number):&#10;        &quot;&quot;&quot;Check a single phone number&quot;&quot;&quot;&#10;        self.current_phone_number = phone_number&#10;        try:&#10;            self.search_phone_number(phone_number)&#10;            self.handle_continuation()&#10;&#10;            if self.reached_success:&#10;                return {'phone': phone_number, 'status': 'success', 'message': 'Verification code page reached'}&#10;            elif self.error_message:&#10;                return {'phone': phone_number, 'status': 'failed', 'message': self.error_message}&#10;            else:&#10;                return {'phone': phone_number, 'status': 'failed', 'message': 'Unknown error - didn\'t reach verification page'}&#10;        except Exception as e:&#10;            logger.error(f&quot;Error checking {phone_number}: {e}&quot;)&#10;            return {'phone': phone_number, 'status': 'error', 'message': str(e)}&#10;&#10;&#10;def check_single_number(phone_number):&#10;    &quot;&quot;&quot;Worker function to check a single phone number&quot;&quot;&quot;&#10;    checker = FacebookNumberChecker(headless=False)&#10;    try:&#10;        checker.setup_driver()&#10;        result = checker.check_number(phone_number)&#10;        logger.info(f&quot;Completed check for {phone_number}: {result['status']}&quot;)&#10;        return result&#10;    except Exception as e:&#10;        logger.error(f&quot;Worker error for {phone_number}: {e}&quot;)&#10;        return {'phone': phone_number, 'status': 'error', 'message': str(e)}&#10;    finally:&#10;        checker.close()&#10;&#10;&#10;def string_to_number_array(data_str):&#10;    &quot;&quot;&quot;Convert multi-line string of numbers to list&quot;&quot;&quot;&#10;    return [num.strip() for num in data_str.split('\n') if num.strip()]&#10;&#10;&#10;def worker_process_numbers(worker_id, phone_queue, results_list, results_lock):&#10;    &quot;&quot;&quot;Worker that processes multiple phone numbers with one browser instance&quot;&quot;&quot;&#10;    checker = FacebookNumberChecker(headless=False)&#10;    phones_processed = 0&#10;&#10;    try:&#10;        checker.setup_driver()&#10;        logger.info(f&quot;Worker {worker_id} browser ready&quot;)&#10;&#10;        while True:&#10;            try:&#10;                phone_number = phone_queue.get(timeout=1)&#10;&#10;                # Reset state&#10;                checker.continuation = True&#10;                checker.reached_success = False&#10;                checker.error_message = None&#10;&#10;                logger.info(f&quot;Worker {worker_id} checking: {phone_number}&quot;)&#10;                result = checker.check_number(phone_number)&#10;                phones_processed += 1&#10;&#10;                # Store result&#10;                with results_lock:&#10;                    results_list.append(result)&#10;                    logger.info(f&quot;Progress: {len(results_list)}/{phone_queue.qsize() + len(results_list)} completed&quot;)&#10;&#10;                phone_queue.task_done()&#10;&#10;            except queue.Empty:&#10;                logger.info(f&quot;Worker {worker_id} finished - processed {phones_processed} numbers&quot;)&#10;                break&#10;&#10;    except Exception as e:&#10;        logger.error(f&quot;Worker {worker_id} error: {e}&quot;)&#10;    finally:&#10;        input(&quot;Enter to finally close&quot;)&#10;        if checker.page:&#10;            checker.page.close()&#10;        if checker.browser:&#10;            checker.browser.close()&#10;        if checker.playwright:&#10;            checker.playwright.stop()&#10;        logger.info(f&quot;Worker {worker_id} browser closed&quot;)&#10;&#10;&#10;def print_summary(results):&#10;    &quot;&quot;&quot;Print final summary of results&quot;&quot;&quot;&#10;    logger.info(&quot;=&quot; * 50)&#10;    logger.info(&quot;FINAL RESULTS:&quot;)&#10;    logger.info(&quot;=&quot; * 50)&#10;&#10;    success_count = sum(1 for r in results if r['status'] == 'success')&#10;    error_count = sum(1 for r in results if r['status'] == 'error')&#10;&#10;    logger.info(f&quot;Total checked: {len(results)}&quot;)&#10;    logger.info(f&quot;Successful: {success_count}&quot;)&#10;    logger.info(f&quot;Errors: {error_count}&quot;)&#10;&#10;    logger.info(&quot;\nDetailed results:&quot;)&#10;    for result in results:&#10;        logger.info(f&quot;{result['phone']}: {result['status']} - {result['message']}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    nums_str = &quot;&quot;&quot;&#10;2250779359702&#10;2250779356403&#10;2250779354097&#10;2250779355845&#10;2250779354549&#10;2250779352567&#10;2250779350481&#10;2250779357023&#10;2250779354188&#10;2250779355447&#10;    &quot;&quot;&quot;&#10;&#10;    nums = string_to_number_array(nums_str)&#10;    phone_queue = queue.Queue()&#10;    for num in nums:&#10;        phone_queue.put(num)&#10;&#10;    results = []&#10;    results_lock = threading.Lock()&#10;    num_workers = 1&#10;&#10;    logger.info(f&quot;Starting to check {len(nums)} phone numbers with {num_workers} concurrent workers&quot;)&#10;&#10;    # Create and start workers&#10;    workers = [&#10;        threading.Thread(target=worker_process_numbers, args=(i, phone_queue, results, results_lock))&#10;        for i in range(num_workers)&#10;    ]&#10;&#10;    for worker in workers:&#10;        worker.start()&#10;&#10;    for worker in workers:&#10;        worker.join()&#10;&#10;    print_summary(results)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>