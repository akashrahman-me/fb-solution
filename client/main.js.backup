// main.js
const {app, BrowserWindow, ipcMain, dialog} = require("electron");
const path = require("path");
const {spawn} = require("child_process");
const http = require("http");
const fs = require("fs");

// Check if running in development or production
// In production (packaged), app.isPackaged is true
const isDev = !app.isPackaged;
const FRONTEND_PORT = 7000;

let backendProcess = null;
let frontendServer = null;
let mainWindow = null;

// Enable logging
console.log("============================================");
console.log("FB OTP Generator Starting...");
console.log("isDev:", isDev);
console.log("__dirname:", __dirname);
console.log("resourcesPath:", process.resourcesPath);
console.log("userData:", app.getPath("userData"));
console.log("============================================");

// Start local HTTP server to serve static files
function startFrontendServer() {
    return new Promise((resolve, reject) => {
        const staticPath = path.join(__dirname, "out");

        console.log("ðŸ” Checking static path:", staticPath);
        if (!fs.existsSync(staticPath)) {
            console.error("âŒ Static path does not exist:", staticPath);
            reject(new Error("Static path not found"));
            return;
        }
        console.log("âœ… Static path exists");

        frontendServer = http.createServer((req, res) => {
            console.log(`ðŸ“„ Request: ${req.url}`);
            // Default to index.html for root path
            let filePath = req.url === "/" ? "/index.html" : req.url;

            // Remove query parameters
            filePath = filePath.split("?")[0];

            // Remove trailing slashes and add index.html for directories
            if (filePath.endsWith("/")) {
                filePath += "index.html";
            }

            const fullPath = path.join(staticPath, filePath);

            // Security check - ensure the path is within staticPath
            const normalizedPath = path.normalize(fullPath);
            if (!normalizedPath.startsWith(staticPath)) {
                res.writeHead(403);
                res.end("Forbidden");
                return;
            }

            // Check if file exists
            fs.stat(normalizedPath, (err, stats) => {
                if (err || !stats.isFile()) {
                    // For Next.js routes, try with .html extension first
                    const htmlPath = normalizedPath + ".html";
                    fs.stat(htmlPath, (err2, stats2) => {
                        if (err2 || !stats2.isFile()) {
                            // If not found, check if it's a Next.js route directory
                            const indexHtmlPath = path.join(normalizedPath, "index.html");
                            fs.stat(indexHtmlPath, (err3, stats3) => {
                                if (err3 || !stats3.isFile()) {
                                    // If still not found, serve the main index.html for client-side routing
                                    const fallbackPath = path.join(staticPath, "index.html");
                                    fs.stat(fallbackPath, (err4, stats4) => {
                                        if (err4 || !stats4.isFile()) {
                                            res.writeHead(404);
                                            res.end("Not Found");
                                            return;
                                        }
                                        serveFile(fallbackPath, res);
                                    });
                                    return;
                                }
                                serveFile(indexHtmlPath, res);
                            });
                            return;
                        }
                        serveFile(htmlPath, res);
                    });
                    return;
                }
                serveFile(normalizedPath, res);
            });
        });

        frontendServer.listen(FRONTEND_PORT, "127.0.0.1", () => {
            console.log(`âœ… Frontend server running on http://127.0.0.1:${FRONTEND_PORT}`);
            resolve();
        });

        frontendServer.on("error", (err) => {
            console.error("Frontend server error:", err);
            reject(err);
        });
    });
}

// Helper function to serve files with correct content types
function serveFile(filePath, res) {
    const ext = path.extname(filePath).toLowerCase();
    const contentTypes = {
        ".html": "text/html",
        ".js": "application/javascript",
        ".css": "text/css",
        ".json": "application/json",
        ".png": "image/png",
        ".jpg": "image/jpeg",
        ".gif": "image/gif",
        ".svg": "image/svg+xml",
        ".ico": "image/x-icon",
        ".woff": "font/woff",
        ".woff2": "font/woff2",
        ".ttf": "font/ttf",
        ".eot": "application/vnd.ms-fontobject",
    };

    const contentType = contentTypes[ext] || "application/octet-stream";

    fs.readFile(filePath, (err, content) => {
        if (err) {
            res.writeHead(500);
            res.end("Error loading file");
            return;
        }
        res.writeHead(200, {"Content-Type": contentType});
        res.end(content);
    });
}

// Stop frontend server
function stopFrontendServer() {
    if (frontendServer) {
        console.log("ðŸ›‘ Stopping frontend server...");
        frontendServer.close();
        frontendServer = null;
    }
}

// Start Python backend
function startBackend() {
    if (isDev) {
        console.log("ðŸ”§ Development mode: Assuming backend is running separately");
        return;
    }

    const backendPath = path.join(process.resourcesPath, "backend", "fb-backend.exe");

    console.log("ï¿½ Checking backend path:", backendPath);
    if (!fs.existsSync(backendPath)) {
        console.error("âŒ Backend not found at:", backendPath);
        dialog.showErrorBox("Backend Missing", `Backend executable not found at: ${backendPath}`);
        return;
    }
    console.log("âœ… Backend found");

    console.log(" Starting backend:", backendPath);

    backendProcess = spawn(backendPath, [], {
        stdio: "pipe",
        cwd: path.dirname(backendPath),
        windowsHide: false, // Hide console window on Windows
    });

    backendProcess.stdout.on("data", (data) => {
        console.log(`[Backend] ${data}`);
    });

    backendProcess.stderr.on("data", (data) => {
        console.error(`[Backend Error] ${data}`);
    });

    backendProcess.on("error", (error) => {
        console.error(`[Backend Process Error]`, error);
    });

    backendProcess.on("close", (code) => {
        console.log(`Backend process exited with code ${code}`);
    });
}

// Stop Python backend
function stopBackend() {
    if (backendProcess) {
        console.log("ðŸ›‘ Stopping backend...");
        backendProcess.kill();
        backendProcess = null;
    }
}

async function createWindow() {
    mainWindow = new BrowserWindow({
        width: 1200,
        height: 800,
        frame: false, // Remove default titlebar
        titleBarStyle: "hidden",
        show: false, // Don't show until ready
        backgroundColor: "#1a1a1a",
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            preload: path.join(__dirname, "preload.js"),
        },
    });

    // Show window when ready to avoid white flash
    mainWindow.once("ready-to-show", () => {
        console.log("âœ… Window ready to show");
        mainWindow.show();
    });

    // Add error handling for web contents
    mainWindow.webContents.on("did-fail-load", (event, errorCode, errorDescription, validatedURL) => {
        console.error("âŒ Failed to load:", errorCode, errorDescription, validatedURL);
        dialog.showErrorBox("Load Error", `Failed to load: ${errorDescription}\nURL: ${validatedURL}`);
    });

    mainWindow.webContents.on("crashed", (event, killed) => {
        console.error("âŒ Renderer crashed:", killed);
        dialog.showErrorBox("Crash", "The application has crashed. Please restart.");
    });

    mainWindow.webContents.on("console-message", (event, level, message, line, sourceId) => {
        console.log(`[Renderer Console] ${message}`);
    });

    // Log when DOM is ready
    mainWindow.webContents.on("dom-ready", () => {
        console.log("âœ… DOM Ready");
    });

    // Log when page finishes loading
    mainWindow.webContents.on("did-finish-load", () => {
        console.log("âœ… Page Finished Loading");
    });

    if (isDev) {
        await mainWindow.loadURL("http://localhost:3000");
        mainWindow.webContents.openDevTools();
    } else {
        try {
            // In production, load from local server on port 7000
            const url = `http://127.0.0.1:${FRONTEND_PORT}`;
            console.log(`ðŸŒ Loading URL: ${url}`);
            await mainWindow.loadURL(url);
            console.log(`âœ… Frontend loaded from ${url}`);
            // DevTools disabled in production
        } catch (error) {
            console.error("âŒ Error loading URL:", error);
            dialog.showErrorBox("Load Error", `Failed to load application: ${error.message}`);
        }
    }
} // Window Controls IPC Handlers
ipcMain.on("window-minimize", (event) => {
    const win = BrowserWindow.fromWebContents(event.sender);
    win?.minimize();
});

ipcMain.on("window-maximize", (event) => {
    const win = BrowserWindow.fromWebContents(event.sender);
    if (win?.isMaximized()) {
        win.unmaximize();
    } else {
        win?.maximize();
    }
});

ipcMain.on("window-close", (event) => {
    const win = BrowserWindow.fromWebContents(event.sender);
    win?.close();
});

// IPC Handlers - Example communication between renderer and main process
ipcMain.on("toMain", (event, data) => {
    console.log("Received from renderer:", data);
    // Send response back
    event.reply("fromMain", {message: "Message received!", echo: data});
});

ipcMain.handle("get-app-path", async () => {
    return app.getPath("userData");
});

app.whenReady().then(async () => {
    try {
        console.log("ðŸš€ App ready, starting services...");

        // Start frontend server in production
        if (!isDev) {
            console.log("ðŸ“¡ Starting frontend server...");
            await startFrontendServer();
            console.log("âœ… Frontend server started");

            // Wait a bit for server to be fully ready
            await new Promise((resolve) => setTimeout(resolve, 500));
        }

        console.log("ðŸ Starting backend...");
        startBackend();

        // Wait a bit for backend to start
        await new Promise((resolve) => setTimeout(resolve, 1000));

        console.log("ðŸªŸ Creating window...");
        await createWindow();
        console.log("âœ… Window created");
    } catch (error) {
        console.error("âŒ Startup error:", error);
        dialog.showErrorBox("Startup Error", `Failed to start application: ${error.message}`);
        app.quit();
    }
});

app.on("window-all-closed", () => {
    stopFrontendServer();
    stopBackend();
    if (process.platform !== "darwin") app.quit();
});

app.on("before-quit", () => {
    stopFrontendServer();
    stopBackend();
});
